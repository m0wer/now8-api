{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ntapi Normal Times API provides estimated time of arrival for public transport vehicles. For a step by step tutorial that covers the installation process and running the project, check Getting started . Structure Tutorials : take you by the hand through a series of steps to install, run and use this software. Topic guides : discuss key topics and concepts at a fairly high level and provide useful background information and explanation. Reference guides : contain technical reference for the code. They describe how it works and how to use it but assume that you have a basic understanding of key concepts. How-to guides : they guide you through the steps involved in addressing key problems and use-cases. They are more advanced than tutorials and assume some knowledge of how this software works. This structure is based on Django's one . You can find more information about it on https://documentation.divio.com/ . Apart from this documentation, the HTTP API documentation can be found at the API server URL in the /docs directory.","title":"ntapi"},{"location":"#ntapi","text":"Normal Times API provides estimated time of arrival for public transport vehicles. For a step by step tutorial that covers the installation process and running the project, check Getting started .","title":"ntapi"},{"location":"#structure","text":"Tutorials : take you by the hand through a series of steps to install, run and use this software. Topic guides : discuss key topics and concepts at a fairly high level and provide useful background information and explanation. Reference guides : contain technical reference for the code. They describe how it works and how to use it but assume that you have a basic understanding of key concepts. How-to guides : they guide you through the steps involved in addressing key problems and use-cases. They are more advanced than tutorials and assume some knowledge of how this software works. This structure is based on Django's one . You can find more information about it on https://documentation.divio.com/ . Apart from this documentation, the HTTP API documentation can be found at the API server URL in the /docs directory.","title":"Structure"},{"location":"howto/contributing/","text":"Contributing To contribute to this project, please follow these guidelines. Tests Write tests for all your changes, including unit and integration tests if appropriate. Commit message guidelines Use the Angular semantic versioning format : {type_of_change}({scope}): {short_description} {full_description} Where: type_of_change is one of: build : Changes that affect the build system or external dependencies. ci : Changes to our CI configuration files and scripts. docs : Documentation only changes. feat : A new feature. fix : A bug fix. perf : A code change that improves performance. refactor : A code change that neither fixes a bug nor adds a feature. style : Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc.). test : Adding missing tests or correcting existing tests. scope : Name of the changed component. short_description : A succinct description of the change. It doesn't need to start with a capitalize letter nor end with a dot. full_description : A summary of the added changes. Commitizen Commitizen is a tool that defines a standard way of committing. It will help you write the commit message and automatically bump the software version and generate a changelog. Once install, start using cz c instead of git commit . Other commands are: cz bump --changelog : Automatic version bump. cz ch : Update the changelog. Pull request guidelines Aggregate your commits in a new branch with a meaningful name for the changes and create a pull request from the web git interface so that other team members can check your changes and propose modifications or approve it. Code quality checks Use psf/black (Python code formatter), PyCQA/flake8 (checks the style and quality of some python code) and python/mypy (Optional static typing for Python). For even more quality checks, install the pre-commit configuration available in the root directory of the repository with pre-commit install . This tool will perform several checks before every commit.","title":"Contributing"},{"location":"howto/contributing/#contributing","text":"To contribute to this project, please follow these guidelines.","title":"Contributing"},{"location":"howto/contributing/#tests","text":"Write tests for all your changes, including unit and integration tests if appropriate.","title":"Tests"},{"location":"howto/contributing/#commit-message-guidelines","text":"Use the Angular semantic versioning format : {type_of_change}({scope}): {short_description} {full_description} Where: type_of_change is one of: build : Changes that affect the build system or external dependencies. ci : Changes to our CI configuration files and scripts. docs : Documentation only changes. feat : A new feature. fix : A bug fix. perf : A code change that improves performance. refactor : A code change that neither fixes a bug nor adds a feature. style : Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc.). test : Adding missing tests or correcting existing tests. scope : Name of the changed component. short_description : A succinct description of the change. It doesn't need to start with a capitalize letter nor end with a dot. full_description : A summary of the added changes.","title":"Commit message guidelines"},{"location":"howto/contributing/#commitizen","text":"Commitizen is a tool that defines a standard way of committing. It will help you write the commit message and automatically bump the software version and generate a changelog. Once install, start using cz c instead of git commit . Other commands are: cz bump --changelog : Automatic version bump. cz ch : Update the changelog.","title":"Commitizen"},{"location":"howto/contributing/#pull-request-guidelines","text":"Aggregate your commits in a new branch with a meaningful name for the changes and create a pull request from the web git interface so that other team members can check your changes and propose modifications or approve it.","title":"Pull request guidelines"},{"location":"howto/contributing/#code-quality-checks","text":"Use psf/black (Python code formatter), PyCQA/flake8 (checks the style and quality of some python code) and python/mypy (Optional static typing for Python). For even more quality checks, install the pre-commit configuration available in the root directory of the repository with pre-commit install . This tool will perform several checks before every commit.","title":"Code quality checks"},{"location":"howto/testing/","text":"Testing We use pytest to test our code. You can run the current tests from the root directory of the repository by executing: python - m pytest Testing scopes There are two main testing scopes: unit testing and integration testing. Unit testing is a testing method by which individual units of source code are tested to determine if they are ready to use, whereas integration testing checks integration between software modules. Unit tests should be fast and not relay on other pieces of code or external dependencies such as databases. Mock them if necessary. Test-driven development We try to follow test-driven development (TDD) principles. The methodology is as follows: Write the unit and integration tests for the functionality to be implemented. Run the tests and check that all of the new tests fail, to ensure that they are actually testing new features. Implement a basic version of the required changes for the new tests to pass. Check that all (old and new) tests pass. Improve the implementation incrementally checking that all tests still pass.","title":"Testing"},{"location":"howto/testing/#testing","text":"We use pytest to test our code. You can run the current tests from the root directory of the repository by executing: python - m pytest","title":"Testing"},{"location":"howto/testing/#testing-scopes","text":"There are two main testing scopes: unit testing and integration testing. Unit testing is a testing method by which individual units of source code are tested to determine if they are ready to use, whereas integration testing checks integration between software modules. Unit tests should be fast and not relay on other pieces of code or external dependencies such as databases. Mock them if necessary.","title":"Testing scopes"},{"location":"howto/testing/#test-driven-development","text":"We try to follow test-driven development (TDD) principles. The methodology is as follows: Write the unit and integration tests for the functionality to be implemented. Run the tests and check that all of the new tests fail, to ensure that they are actually testing new features. Implement a basic version of the required changes for the new tests to pass. Check that all (old and new) tests pass. Improve the implementation incrementally checking that all tests still pass.","title":"Test-driven development"},{"location":"reference/__init__/","text":"Module to store the common classes and exceptions. City pydantic-model City. Attributes: Name Type Description name str City name. transport_types List[ntapi.TransportType] Supported transport types for the city. get_estimations ( self , stop ) async Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[ntapi.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in ntapi/__init__.py @abstractmethod async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: \"\"\"Return ETA for the next vehicles to the stop. Arguments: stop: Stop to get the next vehicle arrival estimations for. Returns: ETA for the next vehicles to the stop. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. \"\"\" get_stops ( self , transport_types = None ) async Return all the stops of the selected transport types. Source code in ntapi/__init__.py @abstractmethod async def get_stops ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: \"\"\"Return all the stops of the selected transport types.\"\"\" CityNameError Invalid city name error. __init__ ( self , city ) special Set the error message and raise the exception. Parameters: Name Type Description Default city str Invalid city name passed. required Source code in ntapi/__init__.py def __init__ ( self , city : str ): \"\"\"Set the error message and raise the exception. Arguments: city: Invalid city name passed. \"\"\" message = f \"Invalid city name ' { city } '.\" super () . __init__ ( message ) Estimation dataclass Estimation class. Attributes: Name Type Description estimation datetime Estimated time of arrival. time Optional[datetime.datetime] Time when the estimation was made. __pydantic_model__ pydantic-model set_time ( value ) classmethod Set time to current time if not specified. Source code in ntapi/__init__.py @validator ( \"time\" ) @classmethod def set_time ( cls , value ): \"\"\"Set time to current time if not specified.\"\"\" if value is None : value = datetime . now () return value set_time ( value ) classmethod Set time to current time if not specified. Source code in ntapi/__init__.py @validator ( \"time\" ) @classmethod def set_time ( cls , value ): \"\"\"Set time to current time if not specified.\"\"\" if value is None : value = datetime . now () return value Line dataclass Transport line. Attributes: Name Type Description id_api Optional[str] Line identifier in the API format. id_user Optional[str] Line identifier in the user format. transport_type Optional[ntapi.TransportType] Transport type of the line. name Optional[str] Line name. __pydantic_model__ pydantic-model default_ids ( values ) classmethod Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/__init__.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) if values [ \"id_api\" ] is None : values [ \"id_api\" ] = values [ \"id_user\" ] elif values [ \"id_user\" ] is None : values [ \"id_user\" ] = values [ \"id_api\" ] return values default_name ( value , values ) classmethod Set the default value for the name if unspecified. Source code in ntapi/__init__.py @validator ( \"name\" , always = True ) @classmethod def default_name ( cls , value , values ): \"\"\"Set the default value for the name if unspecified.\"\"\" if value is None : value = values [ \"id_user\" ] return value default_ids ( values ) classmethod Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/__init__.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) if values [ \"id_api\" ] is None : values [ \"id_api\" ] = values [ \"id_user\" ] elif values [ \"id_user\" ] is None : values [ \"id_user\" ] = values [ \"id_api\" ] return values default_name ( value , values ) classmethod Set the default value for the name if unspecified. Source code in ntapi/__init__.py @validator ( \"name\" , always = True ) @classmethod def default_name ( cls , value , values ): \"\"\"Set the default value for the name if unspecified.\"\"\" if value is None : value = values [ \"id_user\" ] return value Stop dataclass Transportation stop. Attributes: Name Type Description id_user Optional[str] Stop identifier in the user format. id_api Optional[str] Stop identifier in the API format. transport_type Optional[ntapi.TransportType] Transport type of the stop. way Optional[ntapi.Way] Way of the stop. name Optional[str] Name of the stop. coordinates Optional[Tuple[float, float]] Coordinates where the stop is located at. StopIdError Invalid stop ID error. __init__ ( self , stop_id ) special Set the error message and raise the exception. Parameters: Name Type Description Default stop_id str Invalid stop identifier passed. required Source code in ntapi/__init__.py def __init__ ( self , stop_id : str ): \"\"\"Set the error message and raise the exception. Arguments: stop_id: Invalid stop identifier passed. \"\"\" message = f \"Invalid stop ID ' { stop_id } '.\" super () . __init__ ( message ) TransportType Transport type (bus, metro, train, etc.). TransportTypeError Invalid transport type error. __init__ ( self , transport_type , city ) special Set the error message and raise the exception. Parameters: Name Type Description Default transport_type str Invalid transport type passed. required city City City for which the transport type is invalid. required Source code in ntapi/__init__.py def __init__ ( self , transport_type : str , city : City ): \"\"\"Set the error message and raise the exception. Arguments: transport_type: Invalid transport type passed. city: City for which the transport type is invalid. \"\"\" message = ( f \"Invalid transport type ' { transport_type } ' for city \" f \"' { city . name } '.\" ) super () . __init__ ( message ) Vehicle dataclass Transport vehicle. Attributes: Name Type Description identifier str Vehicle identifier. line Line Line to which the vehicle belongs to. name Optional[str] Vehicle name. __pydantic_model__ pydantic-model default_name ( value , values ) classmethod Set the default value for the name if unspecified. Source code in ntapi/__init__.py @validator ( \"name\" , pre = True , always = True ) @classmethod def default_name ( cls , value , values ): \"\"\"Set the default value for the name if unspecified.\"\"\" if value is None : value = values [ \"identifier\" ] return value default_name ( value , values ) classmethod Set the default value for the name if unspecified. Source code in ntapi/__init__.py @validator ( \"name\" , pre = True , always = True ) @classmethod def default_name ( cls , value , values ): \"\"\"Set the default value for the name if unspecified.\"\"\" if value is None : value = values [ \"identifier\" ] return value VehicleEstimation Vehicle estimated time of arrival. Attributes: Name Type Description vehicle Vehicle Vehicle for which the estimation is for. estimation Estimation Estimated time of arrival. Way Way (inbound or outbound). data special Module to store the common objects for the data layer. cache special Module to store the common objects for the cache. cities special Module to store the common classes and functions for all APIs. get_json ( url ) async Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: Type Description dict List of dictionaries with the parsed answer. Source code in ntapi/data/cities/__init__.py async def get_json ( url : HttpUrl ) -> dict : \"\"\"Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: List of dictionaries with the parsed answer. \"\"\" request = requests . get ( url ) request . raise_for_status () return request . json () madrid Module to store the City of Madrid. MadridCity pydantic-model Madrid city. get_estimations ( self , stop ) async Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[ntapi.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in ntapi/data/cities/madrid.py @overrides async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: if stop . transport_type == TransportType . INTERCITY_BUS : response = await get_json ( f \"https://www.crtm.es/\" # type: ignore f \"widgets/api/GetStopsTimes.php\" f \"?codStop= { stop . id_api } &type=1&orderBy=2&stopTimesByIti=3\" ) else : raise NotImplementedError result : List [ VehicleEstimation ] = [] for estimation in response [ \"stopTimes\" ][ \"times\" ][ \"Time\" ]: line = Line ( id_api = estimation [ \"line\" ][ \"codLine\" ], id_user = estimation [ \"line\" ][ \"shortDescription\" ], transport_type = TransportType . INTERCITY_BUS , name = estimation [ \"line\" ][ \"description\" ], ) vehicle = Vehicle ( line = line , identifier = estimation [ \"codIssue\" ]) estimation = Estimation ( estimation = estimation [ \"time\" ], time = response [ \"stopTimes\" ][ \"actualDate\" ], ) result . append ( VehicleEstimation ( vehicle = vehicle , estimation = estimation ) ) return result get_stops ( self , transport_types = None ) async Return all the stops of the selected transport types. Source code in ntapi/data/cities/madrid.py async def get_stops ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: \"\"\"Return all the stops of the selected transport types.\"\"\" raise NotImplementedError MadridStop dataclass Transportation stop. __pydantic_model__ pydantic-model default_ids ( values ) classmethod Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/data/cities/madrid.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) elif values [ \"id_api\" ] is None : try : values [ \"id_api\" ] = ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] + values [ \"id_user\" ] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError elif values [ \"id_user\" ] is None : try : values [ \"id_user\" ] = values [ \"id_api\" ] . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError return values default_ids ( values ) classmethod Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/data/cities/madrid.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) elif values [ \"id_api\" ] is None : try : values [ \"id_api\" ] = ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] + values [ \"id_user\" ] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError elif values [ \"id_user\" ] is None : try : values [ \"id_user\" ] = values [ \"id_api\" ] . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError return values database special Module to store the common objects for the database. entrypoints special Module to store the common objects for the entrypoints. api special Module to store the HTTP REST API. _return_msg ( msg , key = 'msg' ) private Return a dictionary with the provided string. As the value of the provided key. Parameters: Name Type Description Default msg str Message to wrap with the dictionary. required key str Dictionary key to store the msg at. 'msg' Returns: Type Description Dict[str, str] Resulting dictionary: {key: msg} . Source code in ntapi/entrypoints/api/__init__.py def _return_msg ( msg : str , key : str = \"msg\" ) -> Dict [ str , str ]: \"\"\"Return a dictionary with the provided string. As the value of the provided key. Arguments: msg: Message to wrap with the dictionary. key: Dictionary key to store the `msg` at. Returns: Resulting dictionary: `{key: msg}`. \"\"\" return { key : msg } get_estimations_api ( city_name , stop_dict = Depends ( Stop )) async Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default city_name str City name. required stop_dict Stop Stop information. Depends(Stop) Source code in ntapi/entrypoints/api/__init__.py @api . get ( \"/ {city_name} /get_estimations\" ) async def get_estimations_api ( city_name : str , stop_dict : Stop = Depends ( Stop )): \"\"\"Return ETA for the next vehicles to the stop. Arguments: city_name: City name. stop_dict: Stop information. \"\"\" try : result = await get_estimations ( city_name = city_name , stop_dict = asdict ( stop_dict ) ) except NotImplementedError : raise HTTPException ( 404 , \"Can't get estimations for the given stop in the given city.\" ) from NotImplementedError return result logic special Module to store the common objects for the logic layer. Cities Enum with the available cities. assign_city_stop ( city , cities_stops = None ) Assign City and Stop objects corresponding to a city name. Parameters: Name Type Description Default city str Name of the city. Casing is not relevant. required Returns: Type Description Tuple[Type[ntapi.City], Type[ntapi.Stop]] Corresponding City and Stop objects. Exceptions: Type Description CityNameError If an invalid city name is passed. Source code in ntapi/logic/__init__.py @validate_arguments def assign_city_stop ( city : str , cities_stops : Optional [ CitiesStops ] = None , ) -> Tuple [ Type [ City ], Type [ Stop ]]: \"\"\"Assign City and Stop objects corresponding to a city name. Arguments: city: Name of the city. Casing is not relevant. Returns: Corresponding City and Stop objects. Raises: CityNameError: If an invalid city name is passed. \"\"\" if cities_stops is None : cities_stops = CITIES_STOPS try : return cities_stops [ Cities ( city . lower ())] except ValueError : raise CityNameError ( city ) from ValueError get_estimations ( city_name , stop_dict ) async Return ETA for the next vehicles to the stop. stop will be used to instantiate a Stop subclass of the given city. Parameters: Name Type Description Default city_name str City name. required stop_dict dict Dictionary containing the Stop information. At least id_api or id_user must be specified. For some cities, transport_type is also needed. required Returns: Type Description List[ntapi.VehicleEstimation] ETA for the next vehicles to the stop. Source code in ntapi/logic/__init__.py async def get_estimations ( city_name : str , stop_dict : dict ) -> List [ VehicleEstimation ]: \"\"\"Return ETA for the next vehicles to the stop. `stop` will be used to instantiate a Stop subclass of the given city. Arguments: city_name: City name. stop_dict: Dictionary containing the Stop information. At least `id_api` or `id_user` must be specified. For some cities, `transport_type` is also needed. Returns: ETA for the next vehicles to the stop. \"\"\" city_class , stop_class = assign_city_stop ( city_name ) city = city_class () stop = stop_class ( ** stop_dict ) return await city . get_estimations ( stop )","title":"  init  "},{"location":"reference/__init__/#ntapi.City","text":"City. Attributes: Name Type Description name str City name. transport_types List[ntapi.TransportType] Supported transport types for the city.","title":"City"},{"location":"reference/__init__/#ntapi.City.get_estimations","text":"Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[ntapi.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in ntapi/__init__.py @abstractmethod async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: \"\"\"Return ETA for the next vehicles to the stop. Arguments: stop: Stop to get the next vehicle arrival estimations for. Returns: ETA for the next vehicles to the stop. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. \"\"\"","title":"get_estimations()"},{"location":"reference/__init__/#ntapi.City.get_stops","text":"Return all the stops of the selected transport types. Source code in ntapi/__init__.py @abstractmethod async def get_stops ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: \"\"\"Return all the stops of the selected transport types.\"\"\"","title":"get_stops()"},{"location":"reference/__init__/#ntapi.CityNameError","text":"Invalid city name error.","title":"CityNameError"},{"location":"reference/__init__/#ntapi.CityNameError.__init__","text":"Set the error message and raise the exception. Parameters: Name Type Description Default city str Invalid city name passed. required Source code in ntapi/__init__.py def __init__ ( self , city : str ): \"\"\"Set the error message and raise the exception. Arguments: city: Invalid city name passed. \"\"\" message = f \"Invalid city name ' { city } '.\" super () . __init__ ( message )","title":"__init__()"},{"location":"reference/__init__/#ntapi.Estimation","text":"Estimation class. Attributes: Name Type Description estimation datetime Estimated time of arrival. time Optional[datetime.datetime] Time when the estimation was made.","title":"Estimation"},{"location":"reference/__init__/#ntapi.Estimation.__pydantic_model__","text":"","title":"__pydantic_model__"},{"location":"reference/__init__/#ntapi.Estimation.__pydantic_model__.set_time","text":"Set time to current time if not specified. Source code in ntapi/__init__.py @validator ( \"time\" ) @classmethod def set_time ( cls , value ): \"\"\"Set time to current time if not specified.\"\"\" if value is None : value = datetime . now () return value","title":"set_time()"},{"location":"reference/__init__/#ntapi.Estimation.set_time","text":"Set time to current time if not specified. Source code in ntapi/__init__.py @validator ( \"time\" ) @classmethod def set_time ( cls , value ): \"\"\"Set time to current time if not specified.\"\"\" if value is None : value = datetime . now () return value","title":"set_time()"},{"location":"reference/__init__/#ntapi.Line","text":"Transport line. Attributes: Name Type Description id_api Optional[str] Line identifier in the API format. id_user Optional[str] Line identifier in the user format. transport_type Optional[ntapi.TransportType] Transport type of the line. name Optional[str] Line name.","title":"Line"},{"location":"reference/__init__/#ntapi.Line.__pydantic_model__","text":"","title":"__pydantic_model__"},{"location":"reference/__init__/#ntapi.Line.__pydantic_model__.default_ids","text":"Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/__init__.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) if values [ \"id_api\" ] is None : values [ \"id_api\" ] = values [ \"id_user\" ] elif values [ \"id_user\" ] is None : values [ \"id_user\" ] = values [ \"id_api\" ] return values","title":"default_ids()"},{"location":"reference/__init__/#ntapi.Line.__pydantic_model__.default_name","text":"Set the default value for the name if unspecified. Source code in ntapi/__init__.py @validator ( \"name\" , always = True ) @classmethod def default_name ( cls , value , values ): \"\"\"Set the default value for the name if unspecified.\"\"\" if value is None : value = values [ \"id_user\" ] return value","title":"default_name()"},{"location":"reference/__init__/#ntapi.Line.default_ids","text":"Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/__init__.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) if values [ \"id_api\" ] is None : values [ \"id_api\" ] = values [ \"id_user\" ] elif values [ \"id_user\" ] is None : values [ \"id_user\" ] = values [ \"id_api\" ] return values","title":"default_ids()"},{"location":"reference/__init__/#ntapi.Line.default_name","text":"Set the default value for the name if unspecified. Source code in ntapi/__init__.py @validator ( \"name\" , always = True ) @classmethod def default_name ( cls , value , values ): \"\"\"Set the default value for the name if unspecified.\"\"\" if value is None : value = values [ \"id_user\" ] return value","title":"default_name()"},{"location":"reference/__init__/#ntapi.Stop","text":"Transportation stop. Attributes: Name Type Description id_user Optional[str] Stop identifier in the user format. id_api Optional[str] Stop identifier in the API format. transport_type Optional[ntapi.TransportType] Transport type of the stop. way Optional[ntapi.Way] Way of the stop. name Optional[str] Name of the stop. coordinates Optional[Tuple[float, float]] Coordinates where the stop is located at.","title":"Stop"},{"location":"reference/__init__/#ntapi.StopIdError","text":"Invalid stop ID error.","title":"StopIdError"},{"location":"reference/__init__/#ntapi.StopIdError.__init__","text":"Set the error message and raise the exception. Parameters: Name Type Description Default stop_id str Invalid stop identifier passed. required Source code in ntapi/__init__.py def __init__ ( self , stop_id : str ): \"\"\"Set the error message and raise the exception. Arguments: stop_id: Invalid stop identifier passed. \"\"\" message = f \"Invalid stop ID ' { stop_id } '.\" super () . __init__ ( message )","title":"__init__()"},{"location":"reference/__init__/#ntapi.TransportType","text":"Transport type (bus, metro, train, etc.).","title":"TransportType"},{"location":"reference/__init__/#ntapi.TransportTypeError","text":"Invalid transport type error.","title":"TransportTypeError"},{"location":"reference/__init__/#ntapi.TransportTypeError.__init__","text":"Set the error message and raise the exception. Parameters: Name Type Description Default transport_type str Invalid transport type passed. required city City City for which the transport type is invalid. required Source code in ntapi/__init__.py def __init__ ( self , transport_type : str , city : City ): \"\"\"Set the error message and raise the exception. Arguments: transport_type: Invalid transport type passed. city: City for which the transport type is invalid. \"\"\" message = ( f \"Invalid transport type ' { transport_type } ' for city \" f \"' { city . name } '.\" ) super () . __init__ ( message )","title":"__init__()"},{"location":"reference/__init__/#ntapi.Vehicle","text":"Transport vehicle. Attributes: Name Type Description identifier str Vehicle identifier. line Line Line to which the vehicle belongs to. name Optional[str] Vehicle name.","title":"Vehicle"},{"location":"reference/__init__/#ntapi.Vehicle.__pydantic_model__","text":"","title":"__pydantic_model__"},{"location":"reference/__init__/#ntapi.Vehicle.__pydantic_model__.default_name","text":"Set the default value for the name if unspecified. Source code in ntapi/__init__.py @validator ( \"name\" , pre = True , always = True ) @classmethod def default_name ( cls , value , values ): \"\"\"Set the default value for the name if unspecified.\"\"\" if value is None : value = values [ \"identifier\" ] return value","title":"default_name()"},{"location":"reference/__init__/#ntapi.Vehicle.default_name","text":"Set the default value for the name if unspecified. Source code in ntapi/__init__.py @validator ( \"name\" , pre = True , always = True ) @classmethod def default_name ( cls , value , values ): \"\"\"Set the default value for the name if unspecified.\"\"\" if value is None : value = values [ \"identifier\" ] return value","title":"default_name()"},{"location":"reference/__init__/#ntapi.VehicleEstimation","text":"Vehicle estimated time of arrival. Attributes: Name Type Description vehicle Vehicle Vehicle for which the estimation is for. estimation Estimation Estimated time of arrival.","title":"VehicleEstimation"},{"location":"reference/__init__/#ntapi.Way","text":"Way (inbound or outbound).","title":"Way"},{"location":"reference/__init__/#ntapi.data","text":"Module to store the common objects for the data layer.","title":"data"},{"location":"reference/__init__/#ntapi.data.cache","text":"Module to store the common objects for the cache.","title":"cache"},{"location":"reference/__init__/#ntapi.data.cities","text":"Module to store the common classes and functions for all APIs.","title":"cities"},{"location":"reference/__init__/#ntapi.data.cities.get_json","text":"Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: Type Description dict List of dictionaries with the parsed answer. Source code in ntapi/data/cities/__init__.py async def get_json ( url : HttpUrl ) -> dict : \"\"\"Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: List of dictionaries with the parsed answer. \"\"\" request = requests . get ( url ) request . raise_for_status () return request . json ()","title":"get_json()"},{"location":"reference/__init__/#ntapi.data.cities.madrid","text":"Module to store the City of Madrid.","title":"madrid"},{"location":"reference/__init__/#ntapi.data.cities.madrid.MadridCity","text":"Madrid city.","title":"MadridCity"},{"location":"reference/__init__/#ntapi.data.cities.madrid.MadridCity.get_estimations","text":"Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[ntapi.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in ntapi/data/cities/madrid.py @overrides async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: if stop . transport_type == TransportType . INTERCITY_BUS : response = await get_json ( f \"https://www.crtm.es/\" # type: ignore f \"widgets/api/GetStopsTimes.php\" f \"?codStop= { stop . id_api } &type=1&orderBy=2&stopTimesByIti=3\" ) else : raise NotImplementedError result : List [ VehicleEstimation ] = [] for estimation in response [ \"stopTimes\" ][ \"times\" ][ \"Time\" ]: line = Line ( id_api = estimation [ \"line\" ][ \"codLine\" ], id_user = estimation [ \"line\" ][ \"shortDescription\" ], transport_type = TransportType . INTERCITY_BUS , name = estimation [ \"line\" ][ \"description\" ], ) vehicle = Vehicle ( line = line , identifier = estimation [ \"codIssue\" ]) estimation = Estimation ( estimation = estimation [ \"time\" ], time = response [ \"stopTimes\" ][ \"actualDate\" ], ) result . append ( VehicleEstimation ( vehicle = vehicle , estimation = estimation ) ) return result","title":"get_estimations()"},{"location":"reference/__init__/#ntapi.data.cities.madrid.MadridCity.get_stops","text":"Return all the stops of the selected transport types. Source code in ntapi/data/cities/madrid.py async def get_stops ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: \"\"\"Return all the stops of the selected transport types.\"\"\" raise NotImplementedError","title":"get_stops()"},{"location":"reference/__init__/#ntapi.data.cities.madrid.MadridStop","text":"Transportation stop.","title":"MadridStop"},{"location":"reference/__init__/#ntapi.data.cities.madrid.MadridStop.__pydantic_model__","text":"default_ids ( values ) classmethod Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/data/cities/madrid.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) elif values [ \"id_api\" ] is None : try : values [ \"id_api\" ] = ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] + values [ \"id_user\" ] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError elif values [ \"id_user\" ] is None : try : values [ \"id_user\" ] = values [ \"id_api\" ] . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError return values","title":"__pydantic_model__"},{"location":"reference/__init__/#ntapi.data.cities.madrid.MadridStop.default_ids","text":"Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/data/cities/madrid.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) elif values [ \"id_api\" ] is None : try : values [ \"id_api\" ] = ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] + values [ \"id_user\" ] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError elif values [ \"id_user\" ] is None : try : values [ \"id_user\" ] = values [ \"id_api\" ] . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError return values","title":"default_ids()"},{"location":"reference/__init__/#ntapi.data.database","text":"Module to store the common objects for the database.","title":"database"},{"location":"reference/__init__/#ntapi.entrypoints","text":"Module to store the common objects for the entrypoints.","title":"entrypoints"},{"location":"reference/__init__/#ntapi.entrypoints.api","text":"Module to store the HTTP REST API.","title":"api"},{"location":"reference/__init__/#ntapi.entrypoints.api._return_msg","text":"Return a dictionary with the provided string. As the value of the provided key. Parameters: Name Type Description Default msg str Message to wrap with the dictionary. required key str Dictionary key to store the msg at. 'msg' Returns: Type Description Dict[str, str] Resulting dictionary: {key: msg} . Source code in ntapi/entrypoints/api/__init__.py def _return_msg ( msg : str , key : str = \"msg\" ) -> Dict [ str , str ]: \"\"\"Return a dictionary with the provided string. As the value of the provided key. Arguments: msg: Message to wrap with the dictionary. key: Dictionary key to store the `msg` at. Returns: Resulting dictionary: `{key: msg}`. \"\"\" return { key : msg }","title":"_return_msg()"},{"location":"reference/__init__/#ntapi.entrypoints.api.get_estimations_api","text":"Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default city_name str City name. required stop_dict Stop Stop information. Depends(Stop) Source code in ntapi/entrypoints/api/__init__.py @api . get ( \"/ {city_name} /get_estimations\" ) async def get_estimations_api ( city_name : str , stop_dict : Stop = Depends ( Stop )): \"\"\"Return ETA for the next vehicles to the stop. Arguments: city_name: City name. stop_dict: Stop information. \"\"\" try : result = await get_estimations ( city_name = city_name , stop_dict = asdict ( stop_dict ) ) except NotImplementedError : raise HTTPException ( 404 , \"Can't get estimations for the given stop in the given city.\" ) from NotImplementedError return result","title":"get_estimations_api()"},{"location":"reference/__init__/#ntapi.logic","text":"Module to store the common objects for the logic layer.","title":"logic"},{"location":"reference/__init__/#ntapi.logic.Cities","text":"Enum with the available cities.","title":"Cities"},{"location":"reference/__init__/#ntapi.logic.assign_city_stop","text":"Assign City and Stop objects corresponding to a city name. Parameters: Name Type Description Default city str Name of the city. Casing is not relevant. required Returns: Type Description Tuple[Type[ntapi.City], Type[ntapi.Stop]] Corresponding City and Stop objects. Exceptions: Type Description CityNameError If an invalid city name is passed. Source code in ntapi/logic/__init__.py @validate_arguments def assign_city_stop ( city : str , cities_stops : Optional [ CitiesStops ] = None , ) -> Tuple [ Type [ City ], Type [ Stop ]]: \"\"\"Assign City and Stop objects corresponding to a city name. Arguments: city: Name of the city. Casing is not relevant. Returns: Corresponding City and Stop objects. Raises: CityNameError: If an invalid city name is passed. \"\"\" if cities_stops is None : cities_stops = CITIES_STOPS try : return cities_stops [ Cities ( city . lower ())] except ValueError : raise CityNameError ( city ) from ValueError","title":"assign_city_stop()"},{"location":"reference/__init__/#ntapi.logic.get_estimations","text":"Return ETA for the next vehicles to the stop. stop will be used to instantiate a Stop subclass of the given city. Parameters: Name Type Description Default city_name str City name. required stop_dict dict Dictionary containing the Stop information. At least id_api or id_user must be specified. For some cities, transport_type is also needed. required Returns: Type Description List[ntapi.VehicleEstimation] ETA for the next vehicles to the stop. Source code in ntapi/logic/__init__.py async def get_estimations ( city_name : str , stop_dict : dict ) -> List [ VehicleEstimation ]: \"\"\"Return ETA for the next vehicles to the stop. `stop` will be used to instantiate a Stop subclass of the given city. Arguments: city_name: City name. stop_dict: Dictionary containing the Stop information. At least `id_api` or `id_user` must be specified. For some cities, `transport_type` is also needed. Returns: ETA for the next vehicles to the stop. \"\"\" city_class , stop_class = assign_city_stop ( city_name ) city = city_class () stop = stop_class ( ** stop_dict ) return await city . get_estimations ( stop )","title":"get_estimations()"},{"location":"reference/data/__init__/","text":"Module to store the common objects for the data layer. cache special Module to store the common objects for the cache. cities special Module to store the common classes and functions for all APIs. get_json ( url ) async Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: Type Description dict List of dictionaries with the parsed answer. Source code in ntapi/data/cities/__init__.py async def get_json ( url : HttpUrl ) -> dict : \"\"\"Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: List of dictionaries with the parsed answer. \"\"\" request = requests . get ( url ) request . raise_for_status () return request . json () madrid Module to store the City of Madrid. MadridCity pydantic-model Madrid city. get_estimations ( self , stop ) async Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[ntapi.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in ntapi/data/cities/madrid.py @overrides async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: if stop . transport_type == TransportType . INTERCITY_BUS : response = await get_json ( f \"https://www.crtm.es/\" # type: ignore f \"widgets/api/GetStopsTimes.php\" f \"?codStop= { stop . id_api } &type=1&orderBy=2&stopTimesByIti=3\" ) else : raise NotImplementedError result : List [ VehicleEstimation ] = [] for estimation in response [ \"stopTimes\" ][ \"times\" ][ \"Time\" ]: line = Line ( id_api = estimation [ \"line\" ][ \"codLine\" ], id_user = estimation [ \"line\" ][ \"shortDescription\" ], transport_type = TransportType . INTERCITY_BUS , name = estimation [ \"line\" ][ \"description\" ], ) vehicle = Vehicle ( line = line , identifier = estimation [ \"codIssue\" ]) estimation = Estimation ( estimation = estimation [ \"time\" ], time = response [ \"stopTimes\" ][ \"actualDate\" ], ) result . append ( VehicleEstimation ( vehicle = vehicle , estimation = estimation ) ) return result get_stops ( self , transport_types = None ) async Return all the stops of the selected transport types. Source code in ntapi/data/cities/madrid.py async def get_stops ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: \"\"\"Return all the stops of the selected transport types.\"\"\" raise NotImplementedError MadridStop dataclass Transportation stop. __pydantic_model__ pydantic-model default_ids ( values ) classmethod Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/data/cities/madrid.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) elif values [ \"id_api\" ] is None : try : values [ \"id_api\" ] = ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] + values [ \"id_user\" ] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError elif values [ \"id_user\" ] is None : try : values [ \"id_user\" ] = values [ \"id_api\" ] . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError return values default_ids ( values ) classmethod Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/data/cities/madrid.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) elif values [ \"id_api\" ] is None : try : values [ \"id_api\" ] = ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] + values [ \"id_user\" ] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError elif values [ \"id_user\" ] is None : try : values [ \"id_user\" ] = values [ \"id_api\" ] . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError return values database special Module to store the common objects for the database.","title":"  init  "},{"location":"reference/data/__init__/#ntapi.data.cache","text":"Module to store the common objects for the cache.","title":"cache"},{"location":"reference/data/__init__/#ntapi.data.cities","text":"Module to store the common classes and functions for all APIs.","title":"cities"},{"location":"reference/data/__init__/#ntapi.data.cities.get_json","text":"Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: Type Description dict List of dictionaries with the parsed answer. Source code in ntapi/data/cities/__init__.py async def get_json ( url : HttpUrl ) -> dict : \"\"\"Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: List of dictionaries with the parsed answer. \"\"\" request = requests . get ( url ) request . raise_for_status () return request . json ()","title":"get_json()"},{"location":"reference/data/__init__/#ntapi.data.cities.madrid","text":"Module to store the City of Madrid.","title":"madrid"},{"location":"reference/data/__init__/#ntapi.data.cities.madrid.MadridCity","text":"Madrid city.","title":"MadridCity"},{"location":"reference/data/__init__/#ntapi.data.cities.madrid.MadridCity.get_estimations","text":"Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[ntapi.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in ntapi/data/cities/madrid.py @overrides async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: if stop . transport_type == TransportType . INTERCITY_BUS : response = await get_json ( f \"https://www.crtm.es/\" # type: ignore f \"widgets/api/GetStopsTimes.php\" f \"?codStop= { stop . id_api } &type=1&orderBy=2&stopTimesByIti=3\" ) else : raise NotImplementedError result : List [ VehicleEstimation ] = [] for estimation in response [ \"stopTimes\" ][ \"times\" ][ \"Time\" ]: line = Line ( id_api = estimation [ \"line\" ][ \"codLine\" ], id_user = estimation [ \"line\" ][ \"shortDescription\" ], transport_type = TransportType . INTERCITY_BUS , name = estimation [ \"line\" ][ \"description\" ], ) vehicle = Vehicle ( line = line , identifier = estimation [ \"codIssue\" ]) estimation = Estimation ( estimation = estimation [ \"time\" ], time = response [ \"stopTimes\" ][ \"actualDate\" ], ) result . append ( VehicleEstimation ( vehicle = vehicle , estimation = estimation ) ) return result","title":"get_estimations()"},{"location":"reference/data/__init__/#ntapi.data.cities.madrid.MadridCity.get_stops","text":"Return all the stops of the selected transport types. Source code in ntapi/data/cities/madrid.py async def get_stops ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: \"\"\"Return all the stops of the selected transport types.\"\"\" raise NotImplementedError","title":"get_stops()"},{"location":"reference/data/__init__/#ntapi.data.cities.madrid.MadridStop","text":"Transportation stop.","title":"MadridStop"},{"location":"reference/data/__init__/#ntapi.data.cities.madrid.MadridStop.__pydantic_model__","text":"","title":"__pydantic_model__"},{"location":"reference/data/__init__/#ntapi.data.cities.madrid.MadridStop.__pydantic_model__.default_ids","text":"Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/data/cities/madrid.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) elif values [ \"id_api\" ] is None : try : values [ \"id_api\" ] = ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] + values [ \"id_user\" ] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError elif values [ \"id_user\" ] is None : try : values [ \"id_user\" ] = values [ \"id_api\" ] . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError return values","title":"default_ids()"},{"location":"reference/data/__init__/#ntapi.data.cities.madrid.MadridStop.default_ids","text":"Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/data/cities/madrid.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) elif values [ \"id_api\" ] is None : try : values [ \"id_api\" ] = ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] + values [ \"id_user\" ] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError elif values [ \"id_user\" ] is None : try : values [ \"id_user\" ] = values [ \"id_api\" ] . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError return values","title":"default_ids()"},{"location":"reference/data/__init__/#ntapi.data.database","text":"Module to store the common objects for the database.","title":"database"},{"location":"reference/data/cities/__init__/","text":"Module to store the common classes and functions for all APIs. get_json ( url ) async Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: Type Description dict List of dictionaries with the parsed answer. Source code in ntapi/data/cities/__init__.py async def get_json ( url : HttpUrl ) -> dict : \"\"\"Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: List of dictionaries with the parsed answer. \"\"\" request = requests . get ( url ) request . raise_for_status () return request . json () madrid Module to store the City of Madrid. MadridCity pydantic-model Madrid city. get_estimations ( self , stop ) async Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[ntapi.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in ntapi/data/cities/madrid.py @overrides async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: if stop . transport_type == TransportType . INTERCITY_BUS : response = await get_json ( f \"https://www.crtm.es/\" # type: ignore f \"widgets/api/GetStopsTimes.php\" f \"?codStop= { stop . id_api } &type=1&orderBy=2&stopTimesByIti=3\" ) else : raise NotImplementedError result : List [ VehicleEstimation ] = [] for estimation in response [ \"stopTimes\" ][ \"times\" ][ \"Time\" ]: line = Line ( id_api = estimation [ \"line\" ][ \"codLine\" ], id_user = estimation [ \"line\" ][ \"shortDescription\" ], transport_type = TransportType . INTERCITY_BUS , name = estimation [ \"line\" ][ \"description\" ], ) vehicle = Vehicle ( line = line , identifier = estimation [ \"codIssue\" ]) estimation = Estimation ( estimation = estimation [ \"time\" ], time = response [ \"stopTimes\" ][ \"actualDate\" ], ) result . append ( VehicleEstimation ( vehicle = vehicle , estimation = estimation ) ) return result get_stops ( self , transport_types = None ) async Return all the stops of the selected transport types. Source code in ntapi/data/cities/madrid.py async def get_stops ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: \"\"\"Return all the stops of the selected transport types.\"\"\" raise NotImplementedError MadridStop dataclass Transportation stop. __pydantic_model__ pydantic-model default_ids ( values ) classmethod Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/data/cities/madrid.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) elif values [ \"id_api\" ] is None : try : values [ \"id_api\" ] = ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] + values [ \"id_user\" ] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError elif values [ \"id_user\" ] is None : try : values [ \"id_user\" ] = values [ \"id_api\" ] . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError return values default_ids ( values ) classmethod Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/data/cities/madrid.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) elif values [ \"id_api\" ] is None : try : values [ \"id_api\" ] = ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] + values [ \"id_user\" ] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError elif values [ \"id_user\" ] is None : try : values [ \"id_user\" ] = values [ \"id_api\" ] . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError return values","title":"  init  "},{"location":"reference/data/cities/__init__/#ntapi.data.cities.get_json","text":"Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: Type Description dict List of dictionaries with the parsed answer. Source code in ntapi/data/cities/__init__.py async def get_json ( url : HttpUrl ) -> dict : \"\"\"Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: List of dictionaries with the parsed answer. \"\"\" request = requests . get ( url ) request . raise_for_status () return request . json ()","title":"get_json()"},{"location":"reference/data/cities/__init__/#ntapi.data.cities.madrid","text":"Module to store the City of Madrid.","title":"madrid"},{"location":"reference/data/cities/__init__/#ntapi.data.cities.madrid.MadridCity","text":"Madrid city.","title":"MadridCity"},{"location":"reference/data/cities/__init__/#ntapi.data.cities.madrid.MadridCity.get_estimations","text":"Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[ntapi.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in ntapi/data/cities/madrid.py @overrides async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: if stop . transport_type == TransportType . INTERCITY_BUS : response = await get_json ( f \"https://www.crtm.es/\" # type: ignore f \"widgets/api/GetStopsTimes.php\" f \"?codStop= { stop . id_api } &type=1&orderBy=2&stopTimesByIti=3\" ) else : raise NotImplementedError result : List [ VehicleEstimation ] = [] for estimation in response [ \"stopTimes\" ][ \"times\" ][ \"Time\" ]: line = Line ( id_api = estimation [ \"line\" ][ \"codLine\" ], id_user = estimation [ \"line\" ][ \"shortDescription\" ], transport_type = TransportType . INTERCITY_BUS , name = estimation [ \"line\" ][ \"description\" ], ) vehicle = Vehicle ( line = line , identifier = estimation [ \"codIssue\" ]) estimation = Estimation ( estimation = estimation [ \"time\" ], time = response [ \"stopTimes\" ][ \"actualDate\" ], ) result . append ( VehicleEstimation ( vehicle = vehicle , estimation = estimation ) ) return result","title":"get_estimations()"},{"location":"reference/data/cities/__init__/#ntapi.data.cities.madrid.MadridCity.get_stops","text":"Return all the stops of the selected transport types. Source code in ntapi/data/cities/madrid.py async def get_stops ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: \"\"\"Return all the stops of the selected transport types.\"\"\" raise NotImplementedError","title":"get_stops()"},{"location":"reference/data/cities/__init__/#ntapi.data.cities.madrid.MadridStop","text":"Transportation stop.","title":"MadridStop"},{"location":"reference/data/cities/__init__/#ntapi.data.cities.madrid.MadridStop.__pydantic_model__","text":"","title":"__pydantic_model__"},{"location":"reference/data/cities/__init__/#ntapi.data.cities.madrid.MadridStop.__pydantic_model__.default_ids","text":"Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/data/cities/madrid.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) elif values [ \"id_api\" ] is None : try : values [ \"id_api\" ] = ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] + values [ \"id_user\" ] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError elif values [ \"id_user\" ] is None : try : values [ \"id_user\" ] = values [ \"id_api\" ] . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError return values","title":"default_ids()"},{"location":"reference/data/cities/__init__/#ntapi.data.cities.madrid.MadridStop.default_ids","text":"Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/data/cities/madrid.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) elif values [ \"id_api\" ] is None : try : values [ \"id_api\" ] = ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] + values [ \"id_user\" ] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError elif values [ \"id_user\" ] is None : try : values [ \"id_user\" ] = values [ \"id_api\" ] . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError return values","title":"default_ids()"},{"location":"reference/data/cities/madrid/","text":"Module to store the City of Madrid. MadridCity pydantic-model Madrid city. get_estimations ( self , stop ) async Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[ntapi.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in ntapi/data/cities/madrid.py @overrides async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: if stop . transport_type == TransportType . INTERCITY_BUS : response = await get_json ( f \"https://www.crtm.es/\" # type: ignore f \"widgets/api/GetStopsTimes.php\" f \"?codStop= { stop . id_api } &type=1&orderBy=2&stopTimesByIti=3\" ) else : raise NotImplementedError result : List [ VehicleEstimation ] = [] for estimation in response [ \"stopTimes\" ][ \"times\" ][ \"Time\" ]: line = Line ( id_api = estimation [ \"line\" ][ \"codLine\" ], id_user = estimation [ \"line\" ][ \"shortDescription\" ], transport_type = TransportType . INTERCITY_BUS , name = estimation [ \"line\" ][ \"description\" ], ) vehicle = Vehicle ( line = line , identifier = estimation [ \"codIssue\" ]) estimation = Estimation ( estimation = estimation [ \"time\" ], time = response [ \"stopTimes\" ][ \"actualDate\" ], ) result . append ( VehicleEstimation ( vehicle = vehicle , estimation = estimation ) ) return result get_stops ( self , transport_types = None ) async Return all the stops of the selected transport types. Source code in ntapi/data/cities/madrid.py async def get_stops ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: \"\"\"Return all the stops of the selected transport types.\"\"\" raise NotImplementedError MadridStop dataclass Transportation stop. __pydantic_model__ pydantic-model default_ids ( values ) classmethod Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/data/cities/madrid.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) elif values [ \"id_api\" ] is None : try : values [ \"id_api\" ] = ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] + values [ \"id_user\" ] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError elif values [ \"id_user\" ] is None : try : values [ \"id_user\" ] = values [ \"id_api\" ] . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError return values default_ids ( values ) classmethod Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/data/cities/madrid.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) elif values [ \"id_api\" ] is None : try : values [ \"id_api\" ] = ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] + values [ \"id_user\" ] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError elif values [ \"id_user\" ] is None : try : values [ \"id_user\" ] = values [ \"id_api\" ] . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError return values","title":"Madrid"},{"location":"reference/data/cities/madrid/#ntapi.data.cities.madrid.MadridCity","text":"Madrid city.","title":"MadridCity"},{"location":"reference/data/cities/madrid/#ntapi.data.cities.madrid.MadridCity.get_estimations","text":"Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[ntapi.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in ntapi/data/cities/madrid.py @overrides async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: if stop . transport_type == TransportType . INTERCITY_BUS : response = await get_json ( f \"https://www.crtm.es/\" # type: ignore f \"widgets/api/GetStopsTimes.php\" f \"?codStop= { stop . id_api } &type=1&orderBy=2&stopTimesByIti=3\" ) else : raise NotImplementedError result : List [ VehicleEstimation ] = [] for estimation in response [ \"stopTimes\" ][ \"times\" ][ \"Time\" ]: line = Line ( id_api = estimation [ \"line\" ][ \"codLine\" ], id_user = estimation [ \"line\" ][ \"shortDescription\" ], transport_type = TransportType . INTERCITY_BUS , name = estimation [ \"line\" ][ \"description\" ], ) vehicle = Vehicle ( line = line , identifier = estimation [ \"codIssue\" ]) estimation = Estimation ( estimation = estimation [ \"time\" ], time = response [ \"stopTimes\" ][ \"actualDate\" ], ) result . append ( VehicleEstimation ( vehicle = vehicle , estimation = estimation ) ) return result","title":"get_estimations()"},{"location":"reference/data/cities/madrid/#ntapi.data.cities.madrid.MadridCity.get_stops","text":"Return all the stops of the selected transport types. Source code in ntapi/data/cities/madrid.py async def get_stops ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: \"\"\"Return all the stops of the selected transport types.\"\"\" raise NotImplementedError","title":"get_stops()"},{"location":"reference/data/cities/madrid/#ntapi.data.cities.madrid.MadridStop","text":"Transportation stop.","title":"MadridStop"},{"location":"reference/data/cities/madrid/#ntapi.data.cities.madrid.MadridStop.__pydantic_model__","text":"","title":"__pydantic_model__"},{"location":"reference/data/cities/madrid/#ntapi.data.cities.madrid.MadridStop.__pydantic_model__.default_ids","text":"Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/data/cities/madrid.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) elif values [ \"id_api\" ] is None : try : values [ \"id_api\" ] = ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] + values [ \"id_user\" ] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError elif values [ \"id_user\" ] is None : try : values [ \"id_user\" ] = values [ \"id_api\" ] . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError return values","title":"default_ids()"},{"location":"reference/data/cities/madrid/#ntapi.data.cities.madrid.MadridStop.default_ids","text":"Set the default value for the id_api or id_user if unspecified. Exceptions: Type Description ValueError If neither id_api nor id_user are defined. Source code in ntapi/data/cities/madrid.py @root_validator @classmethod def default_ids ( cls , values ): \"\"\"Set the default value for the id_api or id_user if unspecified. Raises: ValueError: If neither `id_api` nor `id_user` are defined. \"\"\" if values [ \"id_api\" ] is None and values [ \"id_user\" ] is None : raise ValueError ( \"At least `id_api` or `id_user` have to be specified.\" ) elif values [ \"id_api\" ] is None : try : values [ \"id_api\" ] = ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] + values [ \"id_user\" ] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError elif values [ \"id_user\" ] is None : try : values [ \"id_user\" ] = values [ \"id_api\" ] . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ values [ \"transport_type\" ]] ) except KeyError : raise TransportTypeError ( values [ \"transport_type\" ], MadridCity () ) from KeyError return values","title":"default_ids()"},{"location":"topics/code_structure/","text":"Code structure The main module is contained in the ntapi/ directory. The structure is as follows: ntapi \u251c\u2500\u2500 data \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 cities \u2502 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u251c\u2500\u2500 database \u2502 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 entrypoints \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 api \u2502 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 logic \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 __init__.py As you can see, there are three main directories: data , entrypoints and logic . They are connected between them as follows: +---------------+ | external deps | +---------------+ | +-------|---------+ | | | | +----------+ | | | data | | | +----------+ | | | | | +------------+ | | | logic | | | +------------+ | | | | | +-------------+ | | | entrypoints | | | +-------------+ | | | | +-------|---------+ | +----------+ | frontend | +----------+ Each component should only connect with its contiguous ones. Each component contains a __init__.py file that stores the functions shared in the component, for example a hello_world() function shared among different entrypoints (API, CLI, \u2026). Apart from this components, there is the __init__.py file of the ntapi module. Components Data This component is responsible for accessing the external dependencies providing methods for the logic component that abstract the queries to the database, external APIs and other data sources. Cities Abstraction of city transport APIs and other city data sources. Database Abstraction of the local database. Logic This component obtains data from the data component and process them when called by the entrypoints component. Entrypoints This component provides access to the ntapi package functionality. The main entrypoint is a HTTP REST API but other entrypoints, such as CLIs, should be placed here.","title":"Code structure"},{"location":"topics/code_structure/#code-structure","text":"The main module is contained in the ntapi/ directory. The structure is as follows: ntapi \u251c\u2500\u2500 data \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 cities \u2502 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u251c\u2500\u2500 database \u2502 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 entrypoints \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 api \u2502 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 logic \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 __init__.py As you can see, there are three main directories: data , entrypoints and logic . They are connected between them as follows: +---------------+ | external deps | +---------------+ | +-------|---------+ | | | | +----------+ | | | data | | | +----------+ | | | | | +------------+ | | | logic | | | +------------+ | | | | | +-------------+ | | | entrypoints | | | +-------------+ | | | | +-------|---------+ | +----------+ | frontend | +----------+ Each component should only connect with its contiguous ones. Each component contains a __init__.py file that stores the functions shared in the component, for example a hello_world() function shared among different entrypoints (API, CLI, \u2026). Apart from this components, there is the __init__.py file of the ntapi module.","title":"Code structure"},{"location":"topics/code_structure/#components","text":"","title":"Components"},{"location":"topics/code_structure/#data","text":"This component is responsible for accessing the external dependencies providing methods for the logic component that abstract the queries to the database, external APIs and other data sources.","title":"Data"},{"location":"topics/code_structure/#cities","text":"Abstraction of city transport APIs and other city data sources.","title":"Cities"},{"location":"topics/code_structure/#database","text":"Abstraction of the local database.","title":"Database"},{"location":"topics/code_structure/#logic","text":"This component obtains data from the data component and process them when called by the entrypoints component.","title":"Logic"},{"location":"topics/code_structure/#entrypoints","text":"This component provides access to the ntapi package functionality. The main entrypoint is a HTTP REST API but other entrypoints, such as CLIs, should be placed here.","title":"Entrypoints"},{"location":"tutorials/docker/","text":"Docker The HTTP API server of this project can be run using docker . Building To build the Docker image of the HTTP API server of this project run (from the root directory of this repository): docker build -t local/ntapi . Running Then, to run the server execute (filling the variable values): docker run --rm --name ntapi -p 8000 :8000 -it -e DB_NAME = '' -e DB_HOST = '' -e DB_USER = '' -e DB_PASS = '' -e DB_PORT = '5432' local/ntapi You can then access the HTTP API at http://localhost:8000 .","title":"Docker"},{"location":"tutorials/docker/#docker","text":"The HTTP API server of this project can be run using docker .","title":"Docker"},{"location":"tutorials/docker/#building","text":"To build the Docker image of the HTTP API server of this project run (from the root directory of this repository): docker build -t local/ntapi .","title":"Building"},{"location":"tutorials/docker/#running","text":"Then, to run the server execute (filling the variable values): docker run --rm --name ntapi -p 8000 :8000 -it -e DB_NAME = '' -e DB_HOST = '' -e DB_USER = '' -e DB_PASS = '' -e DB_PORT = '5432' local/ntapi You can then access the HTTP API at http://localhost:8000 .","title":"Running"},{"location":"tutorials/getting_started/","text":"Getting started Installation Run pip install . . Development To install also the development dependencies, run pip install -r requirements.txt Configuration The following environment variables must be defined with the database connection settings: DB_NAME = '' DB_HOST = '' DB_USER = '' DB_PASS = '' DB_PORT = '' You can define them in several ways: manually using export sourcing a script with the export commands saving them in your virtualenv postactivate script ... Running Development For development, you can run the project with: uvicorn ntapi.entrypoints.api:api --reload You can then access the API at http://localhost:8000 and the Swagger UI (interactive API documentation) at http://localhost:8000/docs . Production For production, a process manager is recommended to handle multiple workers, such as gunicorn . For example: gunicorn -b 0 .0.0.0:8000 -w 4 -k uvicorn.workers.UvicornWorker ntapi.entrypoints.api:api Options: -b option specifies the binding host and port. -w option specifies the number of workers. -k option specifies the type of workers, that need to be uvicorn.workers.UvicornWorker as specified at the Uvicorn Documentation .","title":"Getting started"},{"location":"tutorials/getting_started/#getting-started","text":"","title":"Getting started"},{"location":"tutorials/getting_started/#installation","text":"Run pip install . .","title":"Installation"},{"location":"tutorials/getting_started/#development","text":"To install also the development dependencies, run pip install -r requirements.txt","title":"Development"},{"location":"tutorials/getting_started/#configuration","text":"The following environment variables must be defined with the database connection settings: DB_NAME = '' DB_HOST = '' DB_USER = '' DB_PASS = '' DB_PORT = '' You can define them in several ways: manually using export sourcing a script with the export commands saving them in your virtualenv postactivate script ...","title":"Configuration"},{"location":"tutorials/getting_started/#running","text":"","title":"Running"},{"location":"tutorials/getting_started/#development_1","text":"For development, you can run the project with: uvicorn ntapi.entrypoints.api:api --reload You can then access the API at http://localhost:8000 and the Swagger UI (interactive API documentation) at http://localhost:8000/docs .","title":"Development"},{"location":"tutorials/getting_started/#production","text":"For production, a process manager is recommended to handle multiple workers, such as gunicorn . For example: gunicorn -b 0 .0.0.0:8000 -w 4 -k uvicorn.workers.UvicornWorker ntapi.entrypoints.api:api Options: -b option specifies the binding host and port. -w option specifies the number of workers. -k option specifies the type of workers, that need to be uvicorn.workers.UvicornWorker as specified at the Uvicorn Documentation .","title":"Production"}]}