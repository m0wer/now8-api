{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"now8-api now8 (no wait) API provides estimated time of arrival for public transport vehicles. For a step by step tutorial that covers the installation process and running the project, check Getting started . Structure Tutorials : take you by the hand through a series of steps to install, run and use this software. Topic guides : discuss key topics and concepts at a fairly high level and provide useful background information and explanation. Reference guides : contain technical reference for the code. They describe how it works and how to use it but assume that you have a basic understanding of key concepts. How-to guides : they guide you through the steps involved in addressing key problems and use-cases. They are more advanced than tutorials and assume some knowledge of how this software works. This structure is based on Django's one . You can find more information about it on https://documentation.divio.com/ . Apart from this documentation, the HTTP API documentation can be found at the API server URL in the /docs directory.","title":"now8-api"},{"location":"#now8-api","text":"now8 (no wait) API provides estimated time of arrival for public transport vehicles. For a step by step tutorial that covers the installation process and running the project, check Getting started .","title":"now8-api"},{"location":"#structure","text":"Tutorials : take you by the hand through a series of steps to install, run and use this software. Topic guides : discuss key topics and concepts at a fairly high level and provide useful background information and explanation. Reference guides : contain technical reference for the code. They describe how it works and how to use it but assume that you have a basic understanding of key concepts. How-to guides : they guide you through the steps involved in addressing key problems and use-cases. They are more advanced than tutorials and assume some knowledge of how this software works. This structure is based on Django's one . You can find more information about it on https://documentation.divio.com/ . Apart from this documentation, the HTTP API documentation can be found at the API server URL in the /docs directory.","title":"Structure"},{"location":"howto/contributing/","text":"Contributing To contribute to this project, please follow these guidelines. Tests Write tests for all your changes, including unit and integration tests if appropriate. Commit message guidelines Use the Angular semantic versioning format : {type_of_change}({scope}): {short_description} {full_description} Where: type_of_change is one of: build : Changes that affect the build system or external dependencies. ci : Changes to our CI configuration files and scripts. docs : Documentation only changes. feat : A new feature. fix : A bug fix. perf : A code change that improves performance. refactor : A code change that neither fixes a bug nor adds a feature. style : Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc.). test : Adding missing tests or correcting existing tests. scope : Name of the changed component. short_description : A succinct description of the change. It doesn't need to start with a capitalize letter nor end with a dot. full_description : A summary of the added changes. Commitizen Commitizen is a tool that defines a standard way of committing. It will help you write the commit message and automatically bump the software version and generate a changelog. Once install, start using cz c instead of git commit . Other commands are: cz bump --changelog : Automatic version bump. cz ch : Update the changelog. Pull request guidelines Aggregate your commits in a new branch with a meaningful name for the changes and create a pull request from the web git interface so that other team members can check your changes and propose modifications or approve it. Code quality checks Use psf/black (Python code formatter), PyCQA/flake8 (checks the style and quality of some python code) and python/mypy (Optional static typing for Python). For even more quality checks, install the pre-commit configuration available in the root directory of the repository with pre-commit install . This tool will perform several checks before every commit.","title":"Contributing"},{"location":"howto/contributing/#contributing","text":"To contribute to this project, please follow these guidelines.","title":"Contributing"},{"location":"howto/contributing/#tests","text":"Write tests for all your changes, including unit and integration tests if appropriate.","title":"Tests"},{"location":"howto/contributing/#commit-message-guidelines","text":"Use the Angular semantic versioning format : {type_of_change}({scope}): {short_description} {full_description} Where: type_of_change is one of: build : Changes that affect the build system or external dependencies. ci : Changes to our CI configuration files and scripts. docs : Documentation only changes. feat : A new feature. fix : A bug fix. perf : A code change that improves performance. refactor : A code change that neither fixes a bug nor adds a feature. style : Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc.). test : Adding missing tests or correcting existing tests. scope : Name of the changed component. short_description : A succinct description of the change. It doesn't need to start with a capitalize letter nor end with a dot. full_description : A summary of the added changes.","title":"Commit message guidelines"},{"location":"howto/contributing/#commitizen","text":"Commitizen is a tool that defines a standard way of committing. It will help you write the commit message and automatically bump the software version and generate a changelog. Once install, start using cz c instead of git commit . Other commands are: cz bump --changelog : Automatic version bump. cz ch : Update the changelog.","title":"Commitizen"},{"location":"howto/contributing/#pull-request-guidelines","text":"Aggregate your commits in a new branch with a meaningful name for the changes and create a pull request from the web git interface so that other team members can check your changes and propose modifications or approve it.","title":"Pull request guidelines"},{"location":"howto/contributing/#code-quality-checks","text":"Use psf/black (Python code formatter), PyCQA/flake8 (checks the style and quality of some python code) and python/mypy (Optional static typing for Python). For even more quality checks, install the pre-commit configuration available in the root directory of the repository with pre-commit install . This tool will perform several checks before every commit.","title":"Code quality checks"},{"location":"howto/testing/","text":"Testing We use pytest to test our code. You can run the current tests from the root directory of the repository by executing: python - m pytest Testing scopes We use three testing scopes: unit, integration and end-to-end (e2e). Unit testing is a testing method by which individual units of source code are tested to determine if they are ready to use, whereas integration testing checks integration between software modules at the boundaries. Lastly, e2e tetsing checks the system as a whole assessing that the functionality expected by the user works as expected and that there are no system errors. Unit tests should be fast and not relay on unnecessary pieces of code or external dependencies such as databases. Test-driven development We try to follow test-driven development (TDD) principles. The methodology is as follows: Write the unit and integration tests for the functionality to be implemented. Run the tests and check that all of the new tests fail, to ensure that they are actually testing new features. Implement a basic version of the required changes for the new tests to pass. Check that all (old and new) tests pass. Improve the implementation incrementally checking that all tests still pass. One of this cycles might have subcycles. For example, if you want to add a new high level function for which you write an end-to-end (E2E) test, start writing a test for that function and use small cycles of TDD for the helper functions or dependencies in lower level layers that the new function requires.","title":"Testing"},{"location":"howto/testing/#testing","text":"We use pytest to test our code. You can run the current tests from the root directory of the repository by executing: python - m pytest","title":"Testing"},{"location":"howto/testing/#testing-scopes","text":"We use three testing scopes: unit, integration and end-to-end (e2e). Unit testing is a testing method by which individual units of source code are tested to determine if they are ready to use, whereas integration testing checks integration between software modules at the boundaries. Lastly, e2e tetsing checks the system as a whole assessing that the functionality expected by the user works as expected and that there are no system errors. Unit tests should be fast and not relay on unnecessary pieces of code or external dependencies such as databases.","title":"Testing scopes"},{"location":"howto/testing/#test-driven-development","text":"We try to follow test-driven development (TDD) principles. The methodology is as follows: Write the unit and integration tests for the functionality to be implemented. Run the tests and check that all of the new tests fail, to ensure that they are actually testing new features. Implement a basic version of the required changes for the new tests to pass. Check that all (old and new) tests pass. Improve the implementation incrementally checking that all tests still pass. One of this cycles might have subcycles. For example, if you want to add a new high level function for which you write an end-to-end (E2E) test, start writing a test for that function and use small cycles of TDD for the helper functions or dependencies in lower level layers that the new function requires.","title":"Test-driven development"},{"location":"reference/__init__/","text":"Module to store common functions. data special Module to store the common objects for the data layer. cache special Module to store the common objects for the cache. database special Module to store the common objects for the database. SqlEngine dataclass SQL engine class. Attributes: Name Type Description env_prefix str Prefix of the environment variables with the database connection parameters. name Optional[str] Name of the database. user Optional[str] User name of the database. password Optional[str] Password of the database. host Optional[str] Host of the database. port Optional[str] Port of the database. __pydantic_model__ pydantic-model validate_host ( value , values ) classmethod Get host from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"host\" , always = True ) @classmethod def validate_host ( cls , value , values ): \"\"\"Get host from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"HOST\" , \"postgres\" ) if value is None else value ) validate_name ( value , values ) classmethod Get name from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"name\" , always = True ) @classmethod def validate_name ( cls , value , values ): \"\"\"Get name from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"NAME\" , \"postgres\" ) if value is None else value ) validate_password ( value , values ) classmethod Get password from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"password\" , always = True ) @classmethod def validate_password ( cls , value , values ): \"\"\"Get password from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"PASS\" , \"postgres\" ) if value is None else value ) validate_port ( value , values ) classmethod Get port from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"port\" , always = True ) @classmethod def validate_port ( cls , value , values ): \"\"\"Get port from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"PORT\" , \"5432\" ) if value is None else value ) validate_user ( value , values ) classmethod Get user from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"user\" , always = True ) @classmethod def validate_user ( cls , value , values ): \"\"\"Get user from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"USER\" , \"postgres\" ) if value is None else value ) execute_query ( self , query , * args ) async Return the result of executing the passed query. Parameters: Name Type Description Default query str Query to perform. required args Query arguments. () Returns: Type Description List[tuple] The result of executing the passed query. Source code in now8_api/data/database/__init__.py @abstractmethod async def execute_query ( self , query : str , * args ) -> List [ tuple ]: \"\"\"Return the result of executing the passed query. Arguments: query: Query to perform. args: Query arguments. Returns: The result of executing the passed query. \"\"\" get_db_conf ( self ) Return the database connection parameters. Returns: Type Description Dict[str, str] Dictionary with the available database connection parameters. Source code in now8_api/data/database/__init__.py def get_db_conf ( self ) -> Dict [ str , str ]: \"\"\"Return the database connection parameters. Returns: Dictionary with the available database connection parameters. \"\"\" return { \"dbname\" : str ( self . name ), \"user\" : str ( self . user ), \"password\" : str ( self . password ), \"host\" : str ( self . host ), \"port\" : str ( self . port ), } validate_host ( value , values ) classmethod Get host from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"host\" , always = True ) @classmethod def validate_host ( cls , value , values ): \"\"\"Get host from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"HOST\" , \"postgres\" ) if value is None else value ) validate_name ( value , values ) classmethod Get name from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"name\" , always = True ) @classmethod def validate_name ( cls , value , values ): \"\"\"Get name from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"NAME\" , \"postgres\" ) if value is None else value ) validate_password ( value , values ) classmethod Get password from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"password\" , always = True ) @classmethod def validate_password ( cls , value , values ): \"\"\"Get password from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"PASS\" , \"postgres\" ) if value is None else value ) validate_port ( value , values ) classmethod Get port from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"port\" , always = True ) @classmethod def validate_port ( cls , value , values ): \"\"\"Get port from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"PORT\" , \"5432\" ) if value is None else value ) validate_user ( value , values ) classmethod Get user from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"user\" , always = True ) @classmethod def validate_user ( cls , value , values ): \"\"\"Get user from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"USER\" , \"postgres\" ) if value is None else value ) postgres Module to store the PostgreSQL engine. PostgresqlSqlEngine PostgreSQL engine class. execute_query ( self , query , * args ) async Return the result of executing the passed query. Parameters: Name Type Description Default query str Query to perform. required Returns: Type Description List The result of executing the passed query. Source code in now8_api/data/database/postgres.py @retry ( stop = stop_after_attempt ( 3 )) async def execute_query ( self , query : str , * args ) -> List : \"\"\"Return the result of executing the passed query. Arguments: query: Query to perform. Returns: The result of executing the passed query. \"\"\" db_conf = self . get_db_conf () db_conf [ \"database\" ] = db_conf . pop ( \"dbname\" ) try : conn = await asyncpg . connect ( ** db_conf , timeout = 3 ) except socket . gaierror as error : raise ConnectionError ( f \"Can't connect to database: { db_conf } .\" ) from error query_result = await conn . fetch ( query , * args ) await conn . close () return query_result domain special Module to store the common domain objects. City dataclass City. Attributes: Name Type Description name str City name. transport_types List[now8_api.domain.TransportType] Supported transport types for the city. Coordinates dataclass Coordinates (in degrees). Attributes: Name Type Description longitude float Longitude. latitude float Latitude. Estimation dataclass Estimation class. Attributes: Name Type Description estimation datetime Estimated time of arrival. time datetime Time when the estimation was made. Route dataclass Transport route. Attributes: Name Type Description id str Route identifier. code str Route identifier in the user format. transport_type Optional[now8_api.domain.TransportType] Transport type of the route. name Optional[str] Route name. color Color Route color. Stop dataclass Transportation stop. Attributes: Name Type Description id str Stop identifier. code Optional[str] Stop identifier in the user format. name Optional[str] Name of the stop. transport_type Optional[now8_api.domain.TransportType] Transport type of the stop. coordinates Optional[now8_api.domain.Coordinates] Coordinates where the stop is located at. zone Optional[str] Zone where the stop is located at. TransportType Transport type (bus, metro, train, etc.). Vehicle dataclass Transport vehicle. Attributes: Name Type Description id str Vehicle identifier. route_id str Route to which the vehicle belongs to. name Optional[str] Vehicle name. VehicleEstimation dataclass Vehicle estimated time of arrival. Attributes: Name Type Description vehicle Vehicle Vehicle for which the estimation is for. estimation Estimation Estimated time of arrival. Way Way (inbound or outbound). entrypoints special Module to store the entrypoints. api special Module to store the HTTP REST API. dependencies Module to store the endpoint parameter dependencies. main Main API. service special Module to store common service functions. CityNameError Invalid city name error. __init__ ( self , city_name ) special Set the error message and raise the exception. Parameters: Name Type Description Default city_name str Invalid city name passed. required Source code in now8_api/service/__init__.py def __init__ ( self , city_name : str ): \"\"\"Set the error message and raise the exception. Arguments: city_name: Invalid city name passed. \"\"\" message = f \"Invalid city name ' { city_name } '.\" super () . __init__ ( message ) StopIdError Invalid stop ID error. __init__ ( self , stop_id ) special Set the error message and raise the exception. Parameters: Name Type Description Default stop_id str Invalid stop identifier passed. required Source code in now8_api/service/__init__.py def __init__ ( self , stop_id : str ): \"\"\"Set the error message and raise the exception. Arguments: stop_id: Invalid stop identifier passed. \"\"\" message = f \"Invalid stop ID ' { stop_id } '.\" super () . __init__ ( message ) TransportTypeError Invalid transport type error. __init__ ( self , transport_type ) special Set the error message and raise the exception. Parameters: Name Type Description Default transport_type str Invalid transport type passed. required Source code in now8_api/service/__init__.py def __init__ ( self , transport_type : str ): \"\"\"Set the error message and raise the exception. Arguments: transport_type: Invalid transport type passed. \"\"\" message = f \"Invalid transport type ' { transport_type } '.\" super () . __init__ ( message ) city_data special Module to store the common classes and functions for all cities. CityData pydantic-model City data abstract class. Abstracts the city data retrieval. get_estimations ( self , stop ) async Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[now8_api.domain.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. UpstreamError If the upstream city API fails. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: \"\"\"Return ETA for the next vehicles to the stop. Arguments: stop: Stop to get the next vehicle arrival estimations for. Returns: ETA for the next vehicles to the stop. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. UpstreamError: If the upstream city API fails. \"\"\" get_routes_stop ( self , stop ) async Return all the routes that pass through the stop. Parameters: Name Type Description Default stop Stop Transport stop to get the routes for. required Returns: Type Description List[now8_api.domain.Route] Routes that pass through the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_routes_stop ( self , stop : Stop , ) -> List [ Route ]: \"\"\"Return all the routes that pass through the stop. Arguments: stop: Transport stop to get the routes for. Returns: Routes that pass through the stop. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. \"\"\" get_stops_city ( self , transport_types = None ) async Return all the stops of the selected transport types. Parameters: Name Type Description Default transport_types List[now8_api.domain.TransportType] Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. None Returns: Type Description List[now8_api.domain.Stop] All the stops of the selected transport types. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_stops_city ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: \"\"\"Return all the stops of the selected transport types. Arguments: transport_types: Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. Returns: All the stops of the selected transport types. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. \"\"\" get_stops_route ( self , route ) async Return all the stops of the selected route. Parameters: Name Type Description Default route Route Transport route to get the stops for. required Returns: Type Description Tuple[List[now8_api.domain.Stop], List[now8_api.domain.Stop]] Stops of the selected route for both ways in order. Exceptions: Type Description NotImplementedError If the method is not implemented for the route transport type in this city. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_stops_route ( self , route : Route , ) -> Tuple [ List [ Stop ], List [ Stop ]]: \"\"\"Return all the stops of the selected route. Arguments: route: Transport route to get the stops for. Returns: Stops of the selected route for both ways in order. Raises: NotImplementedError: If the method is not implemented for the route transport type in this city. \"\"\" UpstreamError Custom exception for upstream API fauilures. __init__ ( self , message ) special Initialization method. Parameters: Name Type Description Default message Error message. required Source code in now8_api/service/city_data/__init__.py def __init__ ( self , message ): \"\"\"Initialization method. Arguments: message: Error message. \"\"\" super () . __init__ ( message ) get_json ( url ) async Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: Type Description dict List of dictionaries with the parsed answer. Source code in now8_api/service/city_data/__init__.py @retry ( retry = ( retry_if_exception_type ( TimeoutError ) | retry_if_exception_type ( aiohttp . ClientResponseError ) ), stop = stop_after_attempt ( 3 ), wait = wait_exponential ( multiplier = 0.5 ), ) @validate_arguments async def get_json ( url : HttpUrl ) -> dict : \"\"\"Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: List of dictionaries with the parsed answer. \"\"\" async with aiohttp . ClientSession () as session : async with session . get ( url , raise_for_status = True , timeout = 10 , ) as resp : return await resp . json ( content_type = None ) madrid Module to store the city data of Madrid. MadridCityData pydantic-model Madrid city data. get_estimations ( self , stop ) async Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[now8_api.domain.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. UpstreamError If the upstream city API fails. Source code in now8_api/service/city_data/madrid.py @overrides async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: try : response = await get_json ( f \"https://www.crtm.es/\" # type: ignore f \"widgets/api/GetStopsTimes.php\" f \"?codStop=\" f \" { stop . id . removeprefix ( 'par_' ) . removeprefix ( 'est_' ) } &\" f \"type=1&orderBy=2&stopTimesByIti=3\" ) except Exception as error : raise UpstreamError ( \"Upstream error. Check the stop id or try later.\" ) from error result : List [ VehicleEstimation ] = [] for estimation in response [ \"stopTimes\" ][ \"times\" ] . get ( \"Time\" , []): vehicle = Vehicle ( id = estimation [ \"codIssue\" ], route_id = estimation [ \"line\" ][ \"codLine\" ], route_way = Way ( estimation [ \"direction\" ]) if estimation [ \"direction\" ] in [ 0 , 1 ] else None , ) estimation = Estimation ( estimation = estimation [ \"time\" ], time = response [ \"stopTimes\" ][ \"actualDate\" ], ) result . append ( VehicleEstimation ( vehicle = vehicle , estimation = estimation ) ) return result get_routes_stop ( self , stop ) async Return all the routes that pass through the stop. Parameters: Name Type Description Default stop Stop Transport stop to get the routes for. required Returns: Type Description List[now8_api.domain.Route] Routes that pass through the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_routes_stop ( self , stop : Stop , ) -> List [ Route ]: raise NotImplementedError get_stops_city ( self , transport_types = None ) async Return all the stops of the selected transport types. Parameters: Name Type Description Default transport_types List[now8_api.domain.TransportType] Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. None Returns: Type Description List[now8_api.domain.Stop] All the stops of the selected transport types. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_stops_city ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: raise NotImplementedError get_stops_route ( self , route ) async Return all the stops of the selected route. Parameters: Name Type Description Default route Route Transport route to get the stops for. required Returns: Type Description Tuple[List[now8_api.domain.Stop], List[now8_api.domain.Stop]] Stops of the selected route for both ways in order. Exceptions: Type Description NotImplementedError If the method is not implemented for the route transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_stops_route ( self , route : Route , ) -> Tuple [ List [ Stop ], List [ Stop ]]: raise NotImplementedError _stop_id_api ( stop_id_user , transport_type ) private Return the Stop ID in the API format. Parameters: Name Type Description Default stop_id_user str Stop ID in the user format. required transport_type TransportType Stop transport type. required Returns: Type Description str Stop ID in the API format. Exceptions: Type Description TransportTypeError If the transport type is not supported. Source code in now8_api/service/city_data/madrid.py def _stop_id_api ( stop_id_user : str , transport_type : TransportType ) -> str : \"\"\"Return the Stop ID in the API format. Arguments: stop_id_user: Stop ID in the user format. transport_type: Stop transport type. Returns: Stop ID in the API format. Raises: TransportTypeError: If the transport type is not supported. \"\"\" if transport_type not in TRANSPORT_TYPE_STOP_PREFIXES : raise TransportTypeError ( transport_type = transport_type . name ) return TRANSPORT_TYPE_STOP_PREFIXES [ transport_type ] + stop_id_user _stop_id_user ( stop_id_api , transport_type ) private Return the Stop ID in the user format. Parameters: Name Type Description Default stop_id_api str Stop ID in the city API format. required transport_type TransportType Stop transport type. required Returns: Type Description str Stop ID in the user format. Exceptions: Type Description TransportTypeError If the transport type is not supported. Source code in now8_api/service/city_data/madrid.py def _stop_id_user ( stop_id_api : str , transport_type : TransportType ) -> str : \"\"\"Return the Stop ID in the user format. Arguments: stop_id_api: Stop ID in the city API format. transport_type: Stop transport type. Returns: Stop ID in the user format. Raises: TransportTypeError: If the transport type is not supported. \"\"\" if transport_type not in TRANSPORT_TYPE_STOP_PREFIXES : raise TransportTypeError ( transport_type = transport_type . name ) return stop_id_api . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ transport_type ] ) route_service Module to store the main service functions. RouteNotFoundError Custom exception for route not found. __init__ ( self , route_id ) special Initialize ValueError with custom message. Parameters: Name Type Description Default route_id str Route ID that was not found. required Source code in now8_api/service/route_service.py def __init__ ( self , route_id : str ) -> None : \"\"\"Initialize ValueError with custom message. Arguments: route_id: Route ID that was not found. \"\"\" super () . __init__ ( f 'Route \" { route_id } \" not found.' ) RouteService pydantic-model all_routes ( self ) async Return all the routes of the city. Returns: Type Description Dict[str, Dict[str, Union[str, float, dict]]] List of dictionaries with the route ID, transport type, way, name, coordinates and zone of each route. Source code in now8_api/service/route_service.py async def all_routes ( self , ) -> Dict [ str , Dict [ str , Union [ str , float , dict ]]]: \"\"\"Return all the routes of the city. Returns: List of dictionaries with the route ID, transport type, way, name, coordinates and zone of each route. \"\"\" if self . routes_cache is None : await self . initialize_routes_cache () return self . routes_cache initialize_routes_cache ( self ) async Initialize routes_cache if undefined. Source code in now8_api/service/route_service.py async def initialize_routes_cache ( self ) -> None : \"\"\"Initialize `routes_cache` if undefined.\"\"\" table_routes : Table = Table ( \"routes\" ) query : Query = ( Query . from_ ( table_routes ) . select ( table_routes . route_id , table_routes . route_short_name , table_routes . route_long_name , table_routes . route_type , table_routes . route_color , ) . distinct () ) query_result : List [ tuple ] = await self . sql_engine . execute_query ( str ( query ) ) result : Dict [ str , Dict [ str , Union [ str , float , dict ]]] = {} for row in query_result : route_id : str = row [ 0 ] route_code : str = row [ 1 ] route_name : str = row [ 2 ] route_type : int = row [ 3 ] route_color : str = row [ 4 ] route = Route ( id = route_id , code = route_code , name = route_name , transport_type = TransportType ( route_type ), color = Color ( route_color ), ) result [ route . id ] = { \"id\" : route . id , \"code\" : route . code , \"name\" : route . name , \"transport_type\" : route . transport_type . value , \"color\" : str ( route . color . original ()), } self . routes_cache = result route_info ( self , route_id ) async Return the route information. Parameters: Name Type Description Default route_id str Route identifier. required Returns: Type Description Dict[str, Union[str, float]] Dictionary with the route ID, transport type, way, name, coordinates and zone. Exceptions: Type Description RouteNotFoundError If the route_id does not match any route. Source code in now8_api/service/route_service.py async def route_info ( self , route_id : str ) -> Dict [ str , Union [ str , float ]]: \"\"\"Return the route information. Arguments: route_id: Route identifier. Returns: Dictionary with the route ID, transport type, way, name, coordinates and zone. Raises: RouteNotFoundError: If the `route_id` does not match any route. \"\"\" if self . routes_cache is None : await self . initialize_routes_cache () try : return self . routes_cache [ route_id ] except KeyError as error : raise RouteNotFoundError ( route_id = route_id ) from error service Module to store the main service functions. Cities Enum with the available cities. Service pydantic-model Service base class. Attributes: Name Type Description sql_engine SqlEngine SqlEngine instance for the city. exclude ( dict_of_dicts , keys_to_exclude ) Filter out keys of nested dictionaries (second level). Parameters: Name Type Description Default dict_of_dicts Dict[Any, Dict[str, Any]] Nested dictionaries. required keys_to_exclude List[str] List with the keys to exclude. required Returns: Type Description Dict[Any, Dict[str, Any]] Original nested dictionary except the entries with a key in keys_to_exclude of the second level of dictionaries. Source code in now8_api/service/service.py def exclude ( dict_of_dicts : Dict [ Any , Dict [ str , Any ]], keys_to_exclude : List [ str ] ) -> Dict [ Any , Dict [ str , Any ]]: \"\"\"Filter out keys of nested dictionaries (second level). Arguments: dict_of_dicts: Nested dictionaries. keys_to_exclude: List with the keys to exclude. Returns: Original nested dictionary except the entries with a key in `keys_to_exclude` of the second level of dictionaries. \"\"\" if keys_to_exclude is not None : return { key : dict ( filter ( lambda key_value : key_value [ 0 ] not in keys_to_exclude , value . items (), ) ) for key , value in dict_of_dicts . items () } return dict_of_dicts stop_service StopNotFoundError Custom exception for stop not found. __init__ ( self , stop_id ) special Initialize ValueError with custom message. Parameters: Name Type Description Default stop_id str Stop ID that was not found. required Source code in now8_api/service/stop_service.py def __init__ ( self , stop_id : str ) -> None : \"\"\"Initialize ValueError with custom message. Arguments: stop_id: Stop ID that was not found. \"\"\" super () . __init__ ( f 'Stop \" { stop_id } \" not found.' ) StopService pydantic-model Service base class. Attributes: Name Type Description city_data CityData CityData instance for the city. stops_cache Dict[str, Dict[str, Any]] Object to store the stops info. all_stops ( self ) async Return all the stops of the city. Returns: Type Description Dict[str, Dict[str, Union[str, float, dict]]] List of dictionaries with the stop ID, transport type, way, name, coordinates and zone of each stop. Source code in now8_api/service/stop_service.py async def all_stops ( self , ) -> Dict [ str , Dict [ str , Union [ str , float , dict ]]]: \"\"\"Return all the stops of the city. Returns: List of dictionaries with the stop ID, transport type, way, name, coordinates and zone of each stop. \"\"\" if self . stops_cache is None : await self . initialize_stops_cache () return self . stops_cache initialize_stops_cache ( self ) async Initialize stops_cache if undefined. Source code in now8_api/service/stop_service.py async def initialize_stops_cache ( self ) -> None : \"\"\"Initialize `stops_cache` if undefined.\"\"\" table_routes : Table = Table ( \"routes\" ) table_route_stops : Table = Table ( \"route_stops\" ) table_stops : Table = Table ( \"stops\" ) query : Query = ( Query . from_ ( table_routes ) . join ( table_route_stops ) . on ( table_routes . route_id == table_route_stops . route_id ) . join ( table_stops ) . on ( table_route_stops . stop_id == table_stops . stop_id ) . select ( table_stops . stop_id , table_stops . stop_code , table_stops . stop_name , table_stops . stop_lat , table_stops . stop_lon , table_stops . zone_id , table_routes . route_id , table_route_stops . direction_id , ) . distinct () ) query_result : List [ tuple ] = await self . sql_engine . execute_query ( str ( query ) ) result : Dict [ str , Dict [ str , Any ]] = {} for row in query_result : stop_id : str = row [ 0 ] stop_code : str = row [ 1 ] stop_name : str = row [ 2 ] stop_lat : float = row [ 3 ] stop_lon : float = row [ 4 ] stop_zone : str = row [ 5 ] if stop_id not in result : stop = Stop ( id = stop_id , code = stop_code , name = stop_name , coordinates = Coordinates ( latitude = stop_lat , longitude = stop_lon ), zone = stop_zone , ) result [ stop . id ] = { \"id\" : stop . id , \"code\" : stop . code , \"name\" : stop . name , \"longitude\" : stop . coordinates . longitude , \"latitude\" : stop . coordinates . latitude , \"zone\" : stop . zone , \"route_ways\" : [], } route_id : str = row [ 6 ] route_way : int = row [ 7 ] result [ stop . id ][ \"route_ways\" ] . append ( { \"id\" : route_id , \"way\" : route_way } ) self . stops_cache = result stop_estimation ( self , stop_id ) async Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop_id str Stop identifier. required Returns: Type Description List[Dict[str, dict]] ETA for the next vehicles to the stop. Source code in now8_api/service/stop_service.py async def stop_estimation ( self , stop_id : str ) -> List [ Dict [ str , dict ]]: \"\"\"Return ETA for the next vehicles to the stop. Arguments: stop_id: Stop identifier. Returns: ETA for the next vehicles to the stop. \"\"\" stop = Stop ( id = stop_id , transport_type = TransportType . INTERCITY_BUS ) estimations = await self . city_data . get_estimations ( stop ) result : List [ Dict [ str , dict ]] = [ { \"vehicle\" : { \"id\" : v_e . vehicle . id , \"route_way\" : { \"id\" : v_e . vehicle . route_id , \"way\" : v_e . vehicle . route_way . value if v_e . vehicle . route_way is not None else None , }, }, \"estimation\" : { \"estimation\" : v_e . estimation . estimation , \"time\" : v_e . estimation . time , }, } for v_e in estimations ] return result stop_info ( self , stop_id ) async Return the stop information. Parameters: Name Type Description Default stop_id str Stop identifier. required Returns: Type Description Dict[str, Union[str, float, list]] Dictionary with the stop ID, transport type, way, name, coordinates and zone. Exceptions: Type Description StopNotFoundError If the stop_id does not match any stop. Source code in now8_api/service/stop_service.py async def stop_info ( self , stop_id : str ) -> Dict [ str , Union [ str , float , list ]]: \"\"\"Return the stop information. Arguments: stop_id: Stop identifier. Returns: Dictionary with the stop ID, transport type, way, name, coordinates and zone. Raises: StopNotFoundError: If the `stop_id` does not match any stop. \"\"\" if self . stops_cache is None : await self . initialize_stops_cache () try : return self . stops_cache [ stop_id ] except KeyError as error : raise StopNotFoundError ( stop_id = stop_id ) from error","title":"  init  "},{"location":"reference/__init__/#now8_api.data","text":"Module to store the common objects for the data layer.","title":"data"},{"location":"reference/__init__/#now8_api.data.cache","text":"Module to store the common objects for the cache.","title":"cache"},{"location":"reference/__init__/#now8_api.data.database","text":"Module to store the common objects for the database.","title":"database"},{"location":"reference/__init__/#now8_api.data.database.SqlEngine","text":"SQL engine class. Attributes: Name Type Description env_prefix str Prefix of the environment variables with the database connection parameters. name Optional[str] Name of the database. user Optional[str] User name of the database. password Optional[str] Password of the database. host Optional[str] Host of the database. port Optional[str] Port of the database.","title":"SqlEngine"},{"location":"reference/__init__/#now8_api.data.database.SqlEngine.__pydantic_model__","text":"","title":"__pydantic_model__"},{"location":"reference/__init__/#now8_api.data.database.SqlEngine.__pydantic_model__.validate_host","text":"Get host from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"host\" , always = True ) @classmethod def validate_host ( cls , value , values ): \"\"\"Get host from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"HOST\" , \"postgres\" ) if value is None else value )","title":"validate_host()"},{"location":"reference/__init__/#now8_api.data.database.SqlEngine.__pydantic_model__.validate_name","text":"Get name from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"name\" , always = True ) @classmethod def validate_name ( cls , value , values ): \"\"\"Get name from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"NAME\" , \"postgres\" ) if value is None else value )","title":"validate_name()"},{"location":"reference/__init__/#now8_api.data.database.SqlEngine.__pydantic_model__.validate_password","text":"Get password from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"password\" , always = True ) @classmethod def validate_password ( cls , value , values ): \"\"\"Get password from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"PASS\" , \"postgres\" ) if value is None else value )","title":"validate_password()"},{"location":"reference/__init__/#now8_api.data.database.SqlEngine.__pydantic_model__.validate_port","text":"Get port from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"port\" , always = True ) @classmethod def validate_port ( cls , value , values ): \"\"\"Get port from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"PORT\" , \"5432\" ) if value is None else value )","title":"validate_port()"},{"location":"reference/__init__/#now8_api.data.database.SqlEngine.__pydantic_model__.validate_user","text":"Get user from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"user\" , always = True ) @classmethod def validate_user ( cls , value , values ): \"\"\"Get user from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"USER\" , \"postgres\" ) if value is None else value )","title":"validate_user()"},{"location":"reference/__init__/#now8_api.data.database.SqlEngine.execute_query","text":"Return the result of executing the passed query. Parameters: Name Type Description Default query str Query to perform. required args Query arguments. () Returns: Type Description List[tuple] The result of executing the passed query. Source code in now8_api/data/database/__init__.py @abstractmethod async def execute_query ( self , query : str , * args ) -> List [ tuple ]: \"\"\"Return the result of executing the passed query. Arguments: query: Query to perform. args: Query arguments. Returns: The result of executing the passed query. \"\"\"","title":"execute_query()"},{"location":"reference/__init__/#now8_api.data.database.SqlEngine.get_db_conf","text":"Return the database connection parameters. Returns: Type Description Dict[str, str] Dictionary with the available database connection parameters. Source code in now8_api/data/database/__init__.py def get_db_conf ( self ) -> Dict [ str , str ]: \"\"\"Return the database connection parameters. Returns: Dictionary with the available database connection parameters. \"\"\" return { \"dbname\" : str ( self . name ), \"user\" : str ( self . user ), \"password\" : str ( self . password ), \"host\" : str ( self . host ), \"port\" : str ( self . port ), }","title":"get_db_conf()"},{"location":"reference/__init__/#now8_api.data.database.SqlEngine.validate_host","text":"Get host from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"host\" , always = True ) @classmethod def validate_host ( cls , value , values ): \"\"\"Get host from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"HOST\" , \"postgres\" ) if value is None else value )","title":"validate_host()"},{"location":"reference/__init__/#now8_api.data.database.SqlEngine.validate_name","text":"Get name from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"name\" , always = True ) @classmethod def validate_name ( cls , value , values ): \"\"\"Get name from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"NAME\" , \"postgres\" ) if value is None else value )","title":"validate_name()"},{"location":"reference/__init__/#now8_api.data.database.SqlEngine.validate_password","text":"Get password from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"password\" , always = True ) @classmethod def validate_password ( cls , value , values ): \"\"\"Get password from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"PASS\" , \"postgres\" ) if value is None else value )","title":"validate_password()"},{"location":"reference/__init__/#now8_api.data.database.SqlEngine.validate_port","text":"Get port from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"port\" , always = True ) @classmethod def validate_port ( cls , value , values ): \"\"\"Get port from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"PORT\" , \"5432\" ) if value is None else value )","title":"validate_port()"},{"location":"reference/__init__/#now8_api.data.database.SqlEngine.validate_user","text":"Get user from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"user\" , always = True ) @classmethod def validate_user ( cls , value , values ): \"\"\"Get user from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"USER\" , \"postgres\" ) if value is None else value )","title":"validate_user()"},{"location":"reference/__init__/#now8_api.data.database.postgres","text":"Module to store the PostgreSQL engine.","title":"postgres"},{"location":"reference/__init__/#now8_api.data.database.postgres.PostgresqlSqlEngine","text":"PostgreSQL engine class.","title":"PostgresqlSqlEngine"},{"location":"reference/__init__/#now8_api.data.database.postgres.PostgresqlSqlEngine.execute_query","text":"Return the result of executing the passed query. Parameters: Name Type Description Default query str Query to perform. required Returns: Type Description List The result of executing the passed query. Source code in now8_api/data/database/postgres.py @retry ( stop = stop_after_attempt ( 3 )) async def execute_query ( self , query : str , * args ) -> List : \"\"\"Return the result of executing the passed query. Arguments: query: Query to perform. Returns: The result of executing the passed query. \"\"\" db_conf = self . get_db_conf () db_conf [ \"database\" ] = db_conf . pop ( \"dbname\" ) try : conn = await asyncpg . connect ( ** db_conf , timeout = 3 ) except socket . gaierror as error : raise ConnectionError ( f \"Can't connect to database: { db_conf } .\" ) from error query_result = await conn . fetch ( query , * args ) await conn . close () return query_result","title":"execute_query()"},{"location":"reference/__init__/#now8_api.domain","text":"Module to store the common domain objects.","title":"domain"},{"location":"reference/__init__/#now8_api.domain.City","text":"City. Attributes: Name Type Description name str City name. transport_types List[now8_api.domain.TransportType] Supported transport types for the city.","title":"City"},{"location":"reference/__init__/#now8_api.domain.Coordinates","text":"Coordinates (in degrees). Attributes: Name Type Description longitude float Longitude. latitude float Latitude.","title":"Coordinates"},{"location":"reference/__init__/#now8_api.domain.Estimation","text":"Estimation class. Attributes: Name Type Description estimation datetime Estimated time of arrival. time datetime Time when the estimation was made.","title":"Estimation"},{"location":"reference/__init__/#now8_api.domain.Route","text":"Transport route. Attributes: Name Type Description id str Route identifier. code str Route identifier in the user format. transport_type Optional[now8_api.domain.TransportType] Transport type of the route. name Optional[str] Route name. color Color Route color.","title":"Route"},{"location":"reference/__init__/#now8_api.domain.Stop","text":"Transportation stop. Attributes: Name Type Description id str Stop identifier. code Optional[str] Stop identifier in the user format. name Optional[str] Name of the stop. transport_type Optional[now8_api.domain.TransportType] Transport type of the stop. coordinates Optional[now8_api.domain.Coordinates] Coordinates where the stop is located at. zone Optional[str] Zone where the stop is located at.","title":"Stop"},{"location":"reference/__init__/#now8_api.domain.TransportType","text":"Transport type (bus, metro, train, etc.).","title":"TransportType"},{"location":"reference/__init__/#now8_api.domain.Vehicle","text":"Transport vehicle. Attributes: Name Type Description id str Vehicle identifier. route_id str Route to which the vehicle belongs to. name Optional[str] Vehicle name.","title":"Vehicle"},{"location":"reference/__init__/#now8_api.domain.VehicleEstimation","text":"Vehicle estimated time of arrival. Attributes: Name Type Description vehicle Vehicle Vehicle for which the estimation is for. estimation Estimation Estimated time of arrival.","title":"VehicleEstimation"},{"location":"reference/__init__/#now8_api.domain.Way","text":"Way (inbound or outbound).","title":"Way"},{"location":"reference/__init__/#now8_api.entrypoints","text":"Module to store the entrypoints.","title":"entrypoints"},{"location":"reference/__init__/#now8_api.entrypoints.api","text":"Module to store the HTTP REST API.","title":"api"},{"location":"reference/__init__/#now8_api.entrypoints.api.dependencies","text":"Module to store the endpoint parameter dependencies.","title":"dependencies"},{"location":"reference/__init__/#now8_api.entrypoints.api.main","text":"Main API.","title":"main"},{"location":"reference/__init__/#now8_api.service","text":"Module to store common service functions.","title":"service"},{"location":"reference/__init__/#now8_api.service.CityNameError","text":"Invalid city name error.","title":"CityNameError"},{"location":"reference/__init__/#now8_api.service.CityNameError.__init__","text":"Set the error message and raise the exception. Parameters: Name Type Description Default city_name str Invalid city name passed. required Source code in now8_api/service/__init__.py def __init__ ( self , city_name : str ): \"\"\"Set the error message and raise the exception. Arguments: city_name: Invalid city name passed. \"\"\" message = f \"Invalid city name ' { city_name } '.\" super () . __init__ ( message )","title":"__init__()"},{"location":"reference/__init__/#now8_api.service.StopIdError","text":"Invalid stop ID error.","title":"StopIdError"},{"location":"reference/__init__/#now8_api.service.StopIdError.__init__","text":"Set the error message and raise the exception. Parameters: Name Type Description Default stop_id str Invalid stop identifier passed. required Source code in now8_api/service/__init__.py def __init__ ( self , stop_id : str ): \"\"\"Set the error message and raise the exception. Arguments: stop_id: Invalid stop identifier passed. \"\"\" message = f \"Invalid stop ID ' { stop_id } '.\" super () . __init__ ( message )","title":"__init__()"},{"location":"reference/__init__/#now8_api.service.TransportTypeError","text":"Invalid transport type error.","title":"TransportTypeError"},{"location":"reference/__init__/#now8_api.service.TransportTypeError.__init__","text":"Set the error message and raise the exception. Parameters: Name Type Description Default transport_type str Invalid transport type passed. required Source code in now8_api/service/__init__.py def __init__ ( self , transport_type : str ): \"\"\"Set the error message and raise the exception. Arguments: transport_type: Invalid transport type passed. \"\"\" message = f \"Invalid transport type ' { transport_type } '.\" super () . __init__ ( message )","title":"__init__()"},{"location":"reference/__init__/#now8_api.service.city_data","text":"Module to store the common classes and functions for all cities.","title":"city_data"},{"location":"reference/__init__/#now8_api.service.city_data.CityData","text":"City data abstract class. Abstracts the city data retrieval.","title":"CityData"},{"location":"reference/__init__/#now8_api.service.city_data.CityData.get_estimations","text":"Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[now8_api.domain.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. UpstreamError If the upstream city API fails. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: \"\"\"Return ETA for the next vehicles to the stop. Arguments: stop: Stop to get the next vehicle arrival estimations for. Returns: ETA for the next vehicles to the stop. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. UpstreamError: If the upstream city API fails. \"\"\"","title":"get_estimations()"},{"location":"reference/__init__/#now8_api.service.city_data.CityData.get_routes_stop","text":"Return all the routes that pass through the stop. Parameters: Name Type Description Default stop Stop Transport stop to get the routes for. required Returns: Type Description List[now8_api.domain.Route] Routes that pass through the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_routes_stop ( self , stop : Stop , ) -> List [ Route ]: \"\"\"Return all the routes that pass through the stop. Arguments: stop: Transport stop to get the routes for. Returns: Routes that pass through the stop. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. \"\"\"","title":"get_routes_stop()"},{"location":"reference/__init__/#now8_api.service.city_data.CityData.get_stops_city","text":"Return all the stops of the selected transport types. Parameters: Name Type Description Default transport_types List[now8_api.domain.TransportType] Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. None Returns: Type Description List[now8_api.domain.Stop] All the stops of the selected transport types. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_stops_city ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: \"\"\"Return all the stops of the selected transport types. Arguments: transport_types: Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. Returns: All the stops of the selected transport types. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. \"\"\"","title":"get_stops_city()"},{"location":"reference/__init__/#now8_api.service.city_data.CityData.get_stops_route","text":"Return all the stops of the selected route. Parameters: Name Type Description Default route Route Transport route to get the stops for. required Returns: Type Description Tuple[List[now8_api.domain.Stop], List[now8_api.domain.Stop]] Stops of the selected route for both ways in order. Exceptions: Type Description NotImplementedError If the method is not implemented for the route transport type in this city. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_stops_route ( self , route : Route , ) -> Tuple [ List [ Stop ], List [ Stop ]]: \"\"\"Return all the stops of the selected route. Arguments: route: Transport route to get the stops for. Returns: Stops of the selected route for both ways in order. Raises: NotImplementedError: If the method is not implemented for the route transport type in this city. \"\"\"","title":"get_stops_route()"},{"location":"reference/__init__/#now8_api.service.city_data.UpstreamError","text":"Custom exception for upstream API fauilures.","title":"UpstreamError"},{"location":"reference/__init__/#now8_api.service.city_data.UpstreamError.__init__","text":"Initialization method. Parameters: Name Type Description Default message Error message. required Source code in now8_api/service/city_data/__init__.py def __init__ ( self , message ): \"\"\"Initialization method. Arguments: message: Error message. \"\"\" super () . __init__ ( message )","title":"__init__()"},{"location":"reference/__init__/#now8_api.service.city_data.get_json","text":"Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: Type Description dict List of dictionaries with the parsed answer. Source code in now8_api/service/city_data/__init__.py @retry ( retry = ( retry_if_exception_type ( TimeoutError ) | retry_if_exception_type ( aiohttp . ClientResponseError ) ), stop = stop_after_attempt ( 3 ), wait = wait_exponential ( multiplier = 0.5 ), ) @validate_arguments async def get_json ( url : HttpUrl ) -> dict : \"\"\"Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: List of dictionaries with the parsed answer. \"\"\" async with aiohttp . ClientSession () as session : async with session . get ( url , raise_for_status = True , timeout = 10 , ) as resp : return await resp . json ( content_type = None )","title":"get_json()"},{"location":"reference/__init__/#now8_api.service.city_data.madrid","text":"Module to store the city data of Madrid.","title":"madrid"},{"location":"reference/__init__/#now8_api.service.city_data.madrid.MadridCityData","text":"Madrid city data.","title":"MadridCityData"},{"location":"reference/__init__/#now8_api.service.city_data.madrid.MadridCityData.get_estimations","text":"Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[now8_api.domain.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. UpstreamError If the upstream city API fails. Source code in now8_api/service/city_data/madrid.py @overrides async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: try : response = await get_json ( f \"https://www.crtm.es/\" # type: ignore f \"widgets/api/GetStopsTimes.php\" f \"?codStop=\" f \" { stop . id . removeprefix ( 'par_' ) . removeprefix ( 'est_' ) } &\" f \"type=1&orderBy=2&stopTimesByIti=3\" ) except Exception as error : raise UpstreamError ( \"Upstream error. Check the stop id or try later.\" ) from error result : List [ VehicleEstimation ] = [] for estimation in response [ \"stopTimes\" ][ \"times\" ] . get ( \"Time\" , []): vehicle = Vehicle ( id = estimation [ \"codIssue\" ], route_id = estimation [ \"line\" ][ \"codLine\" ], route_way = Way ( estimation [ \"direction\" ]) if estimation [ \"direction\" ] in [ 0 , 1 ] else None , ) estimation = Estimation ( estimation = estimation [ \"time\" ], time = response [ \"stopTimes\" ][ \"actualDate\" ], ) result . append ( VehicleEstimation ( vehicle = vehicle , estimation = estimation ) ) return result","title":"get_estimations()"},{"location":"reference/__init__/#now8_api.service.city_data.madrid.MadridCityData.get_routes_stop","text":"Return all the routes that pass through the stop. Parameters: Name Type Description Default stop Stop Transport stop to get the routes for. required Returns: Type Description List[now8_api.domain.Route] Routes that pass through the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_routes_stop ( self , stop : Stop , ) -> List [ Route ]: raise NotImplementedError","title":"get_routes_stop()"},{"location":"reference/__init__/#now8_api.service.city_data.madrid.MadridCityData.get_stops_city","text":"Return all the stops of the selected transport types. Parameters: Name Type Description Default transport_types List[now8_api.domain.TransportType] Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. None Returns: Type Description List[now8_api.domain.Stop] All the stops of the selected transport types. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_stops_city ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: raise NotImplementedError","title":"get_stops_city()"},{"location":"reference/__init__/#now8_api.service.city_data.madrid.MadridCityData.get_stops_route","text":"Return all the stops of the selected route. Parameters: Name Type Description Default route Route Transport route to get the stops for. required Returns: Type Description Tuple[List[now8_api.domain.Stop], List[now8_api.domain.Stop]] Stops of the selected route for both ways in order. Exceptions: Type Description NotImplementedError If the method is not implemented for the route transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_stops_route ( self , route : Route , ) -> Tuple [ List [ Stop ], List [ Stop ]]: raise NotImplementedError","title":"get_stops_route()"},{"location":"reference/__init__/#now8_api.service.city_data.madrid._stop_id_api","text":"Return the Stop ID in the API format. Parameters: Name Type Description Default stop_id_user str Stop ID in the user format. required transport_type TransportType Stop transport type. required Returns: Type Description str Stop ID in the API format. Exceptions: Type Description TransportTypeError If the transport type is not supported. Source code in now8_api/service/city_data/madrid.py def _stop_id_api ( stop_id_user : str , transport_type : TransportType ) -> str : \"\"\"Return the Stop ID in the API format. Arguments: stop_id_user: Stop ID in the user format. transport_type: Stop transport type. Returns: Stop ID in the API format. Raises: TransportTypeError: If the transport type is not supported. \"\"\" if transport_type not in TRANSPORT_TYPE_STOP_PREFIXES : raise TransportTypeError ( transport_type = transport_type . name ) return TRANSPORT_TYPE_STOP_PREFIXES [ transport_type ] + stop_id_user","title":"_stop_id_api()"},{"location":"reference/__init__/#now8_api.service.city_data.madrid._stop_id_user","text":"Return the Stop ID in the user format. Parameters: Name Type Description Default stop_id_api str Stop ID in the city API format. required transport_type TransportType Stop transport type. required Returns: Type Description str Stop ID in the user format. Exceptions: Type Description TransportTypeError If the transport type is not supported. Source code in now8_api/service/city_data/madrid.py def _stop_id_user ( stop_id_api : str , transport_type : TransportType ) -> str : \"\"\"Return the Stop ID in the user format. Arguments: stop_id_api: Stop ID in the city API format. transport_type: Stop transport type. Returns: Stop ID in the user format. Raises: TransportTypeError: If the transport type is not supported. \"\"\" if transport_type not in TRANSPORT_TYPE_STOP_PREFIXES : raise TransportTypeError ( transport_type = transport_type . name ) return stop_id_api . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ transport_type ] )","title":"_stop_id_user()"},{"location":"reference/__init__/#now8_api.service.route_service","text":"Module to store the main service functions.","title":"route_service"},{"location":"reference/__init__/#now8_api.service.route_service.RouteNotFoundError","text":"Custom exception for route not found.","title":"RouteNotFoundError"},{"location":"reference/__init__/#now8_api.service.route_service.RouteNotFoundError.__init__","text":"Initialize ValueError with custom message. Parameters: Name Type Description Default route_id str Route ID that was not found. required Source code in now8_api/service/route_service.py def __init__ ( self , route_id : str ) -> None : \"\"\"Initialize ValueError with custom message. Arguments: route_id: Route ID that was not found. \"\"\" super () . __init__ ( f 'Route \" { route_id } \" not found.' )","title":"__init__()"},{"location":"reference/__init__/#now8_api.service.route_service.RouteService","text":"","title":"RouteService"},{"location":"reference/__init__/#now8_api.service.route_service.RouteService.all_routes","text":"Return all the routes of the city. Returns: Type Description Dict[str, Dict[str, Union[str, float, dict]]] List of dictionaries with the route ID, transport type, way, name, coordinates and zone of each route. Source code in now8_api/service/route_service.py async def all_routes ( self , ) -> Dict [ str , Dict [ str , Union [ str , float , dict ]]]: \"\"\"Return all the routes of the city. Returns: List of dictionaries with the route ID, transport type, way, name, coordinates and zone of each route. \"\"\" if self . routes_cache is None : await self . initialize_routes_cache () return self . routes_cache","title":"all_routes()"},{"location":"reference/__init__/#now8_api.service.route_service.RouteService.initialize_routes_cache","text":"Initialize routes_cache if undefined. Source code in now8_api/service/route_service.py async def initialize_routes_cache ( self ) -> None : \"\"\"Initialize `routes_cache` if undefined.\"\"\" table_routes : Table = Table ( \"routes\" ) query : Query = ( Query . from_ ( table_routes ) . select ( table_routes . route_id , table_routes . route_short_name , table_routes . route_long_name , table_routes . route_type , table_routes . route_color , ) . distinct () ) query_result : List [ tuple ] = await self . sql_engine . execute_query ( str ( query ) ) result : Dict [ str , Dict [ str , Union [ str , float , dict ]]] = {} for row in query_result : route_id : str = row [ 0 ] route_code : str = row [ 1 ] route_name : str = row [ 2 ] route_type : int = row [ 3 ] route_color : str = row [ 4 ] route = Route ( id = route_id , code = route_code , name = route_name , transport_type = TransportType ( route_type ), color = Color ( route_color ), ) result [ route . id ] = { \"id\" : route . id , \"code\" : route . code , \"name\" : route . name , \"transport_type\" : route . transport_type . value , \"color\" : str ( route . color . original ()), } self . routes_cache = result","title":"initialize_routes_cache()"},{"location":"reference/__init__/#now8_api.service.route_service.RouteService.route_info","text":"Return the route information. Parameters: Name Type Description Default route_id str Route identifier. required Returns: Type Description Dict[str, Union[str, float]] Dictionary with the route ID, transport type, way, name, coordinates and zone. Exceptions: Type Description RouteNotFoundError If the route_id does not match any route. Source code in now8_api/service/route_service.py async def route_info ( self , route_id : str ) -> Dict [ str , Union [ str , float ]]: \"\"\"Return the route information. Arguments: route_id: Route identifier. Returns: Dictionary with the route ID, transport type, way, name, coordinates and zone. Raises: RouteNotFoundError: If the `route_id` does not match any route. \"\"\" if self . routes_cache is None : await self . initialize_routes_cache () try : return self . routes_cache [ route_id ] except KeyError as error : raise RouteNotFoundError ( route_id = route_id ) from error","title":"route_info()"},{"location":"reference/__init__/#now8_api.service.service","text":"Module to store the main service functions.","title":"service"},{"location":"reference/__init__/#now8_api.service.service.Cities","text":"Enum with the available cities.","title":"Cities"},{"location":"reference/__init__/#now8_api.service.service.Service","text":"Service base class. Attributes: Name Type Description sql_engine SqlEngine SqlEngine instance for the city.","title":"Service"},{"location":"reference/__init__/#now8_api.service.service.exclude","text":"Filter out keys of nested dictionaries (second level). Parameters: Name Type Description Default dict_of_dicts Dict[Any, Dict[str, Any]] Nested dictionaries. required keys_to_exclude List[str] List with the keys to exclude. required Returns: Type Description Dict[Any, Dict[str, Any]] Original nested dictionary except the entries with a key in keys_to_exclude of the second level of dictionaries. Source code in now8_api/service/service.py def exclude ( dict_of_dicts : Dict [ Any , Dict [ str , Any ]], keys_to_exclude : List [ str ] ) -> Dict [ Any , Dict [ str , Any ]]: \"\"\"Filter out keys of nested dictionaries (second level). Arguments: dict_of_dicts: Nested dictionaries. keys_to_exclude: List with the keys to exclude. Returns: Original nested dictionary except the entries with a key in `keys_to_exclude` of the second level of dictionaries. \"\"\" if keys_to_exclude is not None : return { key : dict ( filter ( lambda key_value : key_value [ 0 ] not in keys_to_exclude , value . items (), ) ) for key , value in dict_of_dicts . items () } return dict_of_dicts","title":"exclude()"},{"location":"reference/__init__/#now8_api.service.stop_service","text":"","title":"stop_service"},{"location":"reference/__init__/#now8_api.service.stop_service.StopNotFoundError","text":"Custom exception for stop not found.","title":"StopNotFoundError"},{"location":"reference/__init__/#now8_api.service.stop_service.StopNotFoundError.__init__","text":"Initialize ValueError with custom message. Parameters: Name Type Description Default stop_id str Stop ID that was not found. required Source code in now8_api/service/stop_service.py def __init__ ( self , stop_id : str ) -> None : \"\"\"Initialize ValueError with custom message. Arguments: stop_id: Stop ID that was not found. \"\"\" super () . __init__ ( f 'Stop \" { stop_id } \" not found.' )","title":"__init__()"},{"location":"reference/__init__/#now8_api.service.stop_service.StopService","text":"Service base class. Attributes: Name Type Description city_data CityData CityData instance for the city. stops_cache Dict[str, Dict[str, Any]] Object to store the stops info.","title":"StopService"},{"location":"reference/__init__/#now8_api.service.stop_service.StopService.all_stops","text":"Return all the stops of the city. Returns: Type Description Dict[str, Dict[str, Union[str, float, dict]]] List of dictionaries with the stop ID, transport type, way, name, coordinates and zone of each stop. Source code in now8_api/service/stop_service.py async def all_stops ( self , ) -> Dict [ str , Dict [ str , Union [ str , float , dict ]]]: \"\"\"Return all the stops of the city. Returns: List of dictionaries with the stop ID, transport type, way, name, coordinates and zone of each stop. \"\"\" if self . stops_cache is None : await self . initialize_stops_cache () return self . stops_cache","title":"all_stops()"},{"location":"reference/__init__/#now8_api.service.stop_service.StopService.initialize_stops_cache","text":"Initialize stops_cache if undefined. Source code in now8_api/service/stop_service.py async def initialize_stops_cache ( self ) -> None : \"\"\"Initialize `stops_cache` if undefined.\"\"\" table_routes : Table = Table ( \"routes\" ) table_route_stops : Table = Table ( \"route_stops\" ) table_stops : Table = Table ( \"stops\" ) query : Query = ( Query . from_ ( table_routes ) . join ( table_route_stops ) . on ( table_routes . route_id == table_route_stops . route_id ) . join ( table_stops ) . on ( table_route_stops . stop_id == table_stops . stop_id ) . select ( table_stops . stop_id , table_stops . stop_code , table_stops . stop_name , table_stops . stop_lat , table_stops . stop_lon , table_stops . zone_id , table_routes . route_id , table_route_stops . direction_id , ) . distinct () ) query_result : List [ tuple ] = await self . sql_engine . execute_query ( str ( query ) ) result : Dict [ str , Dict [ str , Any ]] = {} for row in query_result : stop_id : str = row [ 0 ] stop_code : str = row [ 1 ] stop_name : str = row [ 2 ] stop_lat : float = row [ 3 ] stop_lon : float = row [ 4 ] stop_zone : str = row [ 5 ] if stop_id not in result : stop = Stop ( id = stop_id , code = stop_code , name = stop_name , coordinates = Coordinates ( latitude = stop_lat , longitude = stop_lon ), zone = stop_zone , ) result [ stop . id ] = { \"id\" : stop . id , \"code\" : stop . code , \"name\" : stop . name , \"longitude\" : stop . coordinates . longitude , \"latitude\" : stop . coordinates . latitude , \"zone\" : stop . zone , \"route_ways\" : [], } route_id : str = row [ 6 ] route_way : int = row [ 7 ] result [ stop . id ][ \"route_ways\" ] . append ( { \"id\" : route_id , \"way\" : route_way } ) self . stops_cache = result","title":"initialize_stops_cache()"},{"location":"reference/__init__/#now8_api.service.stop_service.StopService.stop_estimation","text":"Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop_id str Stop identifier. required Returns: Type Description List[Dict[str, dict]] ETA for the next vehicles to the stop. Source code in now8_api/service/stop_service.py async def stop_estimation ( self , stop_id : str ) -> List [ Dict [ str , dict ]]: \"\"\"Return ETA for the next vehicles to the stop. Arguments: stop_id: Stop identifier. Returns: ETA for the next vehicles to the stop. \"\"\" stop = Stop ( id = stop_id , transport_type = TransportType . INTERCITY_BUS ) estimations = await self . city_data . get_estimations ( stop ) result : List [ Dict [ str , dict ]] = [ { \"vehicle\" : { \"id\" : v_e . vehicle . id , \"route_way\" : { \"id\" : v_e . vehicle . route_id , \"way\" : v_e . vehicle . route_way . value if v_e . vehicle . route_way is not None else None , }, }, \"estimation\" : { \"estimation\" : v_e . estimation . estimation , \"time\" : v_e . estimation . time , }, } for v_e in estimations ] return result","title":"stop_estimation()"},{"location":"reference/__init__/#now8_api.service.stop_service.StopService.stop_info","text":"Return the stop information. Parameters: Name Type Description Default stop_id str Stop identifier. required Returns: Type Description Dict[str, Union[str, float, list]] Dictionary with the stop ID, transport type, way, name, coordinates and zone. Exceptions: Type Description StopNotFoundError If the stop_id does not match any stop. Source code in now8_api/service/stop_service.py async def stop_info ( self , stop_id : str ) -> Dict [ str , Union [ str , float , list ]]: \"\"\"Return the stop information. Arguments: stop_id: Stop identifier. Returns: Dictionary with the stop ID, transport type, way, name, coordinates and zone. Raises: StopNotFoundError: If the `stop_id` does not match any stop. \"\"\" if self . stops_cache is None : await self . initialize_stops_cache () try : return self . stops_cache [ stop_id ] except KeyError as error : raise StopNotFoundError ( stop_id = stop_id ) from error","title":"stop_info()"},{"location":"reference/data/__init__/","text":"Module to store the common objects for the data layer. cache special Module to store the common objects for the cache. database special Module to store the common objects for the database. SqlEngine dataclass SQL engine class. Attributes: Name Type Description env_prefix str Prefix of the environment variables with the database connection parameters. name Optional[str] Name of the database. user Optional[str] User name of the database. password Optional[str] Password of the database. host Optional[str] Host of the database. port Optional[str] Port of the database. __pydantic_model__ pydantic-model validate_host ( value , values ) classmethod Get host from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"host\" , always = True ) @classmethod def validate_host ( cls , value , values ): \"\"\"Get host from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"HOST\" , \"postgres\" ) if value is None else value ) validate_name ( value , values ) classmethod Get name from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"name\" , always = True ) @classmethod def validate_name ( cls , value , values ): \"\"\"Get name from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"NAME\" , \"postgres\" ) if value is None else value ) validate_password ( value , values ) classmethod Get password from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"password\" , always = True ) @classmethod def validate_password ( cls , value , values ): \"\"\"Get password from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"PASS\" , \"postgres\" ) if value is None else value ) validate_port ( value , values ) classmethod Get port from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"port\" , always = True ) @classmethod def validate_port ( cls , value , values ): \"\"\"Get port from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"PORT\" , \"5432\" ) if value is None else value ) validate_user ( value , values ) classmethod Get user from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"user\" , always = True ) @classmethod def validate_user ( cls , value , values ): \"\"\"Get user from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"USER\" , \"postgres\" ) if value is None else value ) execute_query ( self , query , * args ) async Return the result of executing the passed query. Parameters: Name Type Description Default query str Query to perform. required args Query arguments. () Returns: Type Description List[tuple] The result of executing the passed query. Source code in now8_api/data/database/__init__.py @abstractmethod async def execute_query ( self , query : str , * args ) -> List [ tuple ]: \"\"\"Return the result of executing the passed query. Arguments: query: Query to perform. args: Query arguments. Returns: The result of executing the passed query. \"\"\" get_db_conf ( self ) Return the database connection parameters. Returns: Type Description Dict[str, str] Dictionary with the available database connection parameters. Source code in now8_api/data/database/__init__.py def get_db_conf ( self ) -> Dict [ str , str ]: \"\"\"Return the database connection parameters. Returns: Dictionary with the available database connection parameters. \"\"\" return { \"dbname\" : str ( self . name ), \"user\" : str ( self . user ), \"password\" : str ( self . password ), \"host\" : str ( self . host ), \"port\" : str ( self . port ), } validate_host ( value , values ) classmethod Get host from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"host\" , always = True ) @classmethod def validate_host ( cls , value , values ): \"\"\"Get host from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"HOST\" , \"postgres\" ) if value is None else value ) validate_name ( value , values ) classmethod Get name from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"name\" , always = True ) @classmethod def validate_name ( cls , value , values ): \"\"\"Get name from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"NAME\" , \"postgres\" ) if value is None else value ) validate_password ( value , values ) classmethod Get password from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"password\" , always = True ) @classmethod def validate_password ( cls , value , values ): \"\"\"Get password from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"PASS\" , \"postgres\" ) if value is None else value ) validate_port ( value , values ) classmethod Get port from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"port\" , always = True ) @classmethod def validate_port ( cls , value , values ): \"\"\"Get port from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"PORT\" , \"5432\" ) if value is None else value ) validate_user ( value , values ) classmethod Get user from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"user\" , always = True ) @classmethod def validate_user ( cls , value , values ): \"\"\"Get user from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"USER\" , \"postgres\" ) if value is None else value ) postgres Module to store the PostgreSQL engine. PostgresqlSqlEngine PostgreSQL engine class. execute_query ( self , query , * args ) async Return the result of executing the passed query. Parameters: Name Type Description Default query str Query to perform. required Returns: Type Description List The result of executing the passed query. Source code in now8_api/data/database/postgres.py @retry ( stop = stop_after_attempt ( 3 )) async def execute_query ( self , query : str , * args ) -> List : \"\"\"Return the result of executing the passed query. Arguments: query: Query to perform. Returns: The result of executing the passed query. \"\"\" db_conf = self . get_db_conf () db_conf [ \"database\" ] = db_conf . pop ( \"dbname\" ) try : conn = await asyncpg . connect ( ** db_conf , timeout = 3 ) except socket . gaierror as error : raise ConnectionError ( f \"Can't connect to database: { db_conf } .\" ) from error query_result = await conn . fetch ( query , * args ) await conn . close () return query_result","title":"  init  "},{"location":"reference/data/__init__/#now8_api.data.cache","text":"Module to store the common objects for the cache.","title":"cache"},{"location":"reference/data/__init__/#now8_api.data.database","text":"Module to store the common objects for the database.","title":"database"},{"location":"reference/data/__init__/#now8_api.data.database.SqlEngine","text":"SQL engine class. Attributes: Name Type Description env_prefix str Prefix of the environment variables with the database connection parameters. name Optional[str] Name of the database. user Optional[str] User name of the database. password Optional[str] Password of the database. host Optional[str] Host of the database. port Optional[str] Port of the database.","title":"SqlEngine"},{"location":"reference/data/__init__/#now8_api.data.database.SqlEngine.__pydantic_model__","text":"","title":"__pydantic_model__"},{"location":"reference/data/__init__/#now8_api.data.database.SqlEngine.__pydantic_model__.validate_host","text":"Get host from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"host\" , always = True ) @classmethod def validate_host ( cls , value , values ): \"\"\"Get host from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"HOST\" , \"postgres\" ) if value is None else value )","title":"validate_host()"},{"location":"reference/data/__init__/#now8_api.data.database.SqlEngine.__pydantic_model__.validate_name","text":"Get name from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"name\" , always = True ) @classmethod def validate_name ( cls , value , values ): \"\"\"Get name from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"NAME\" , \"postgres\" ) if value is None else value )","title":"validate_name()"},{"location":"reference/data/__init__/#now8_api.data.database.SqlEngine.__pydantic_model__.validate_password","text":"Get password from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"password\" , always = True ) @classmethod def validate_password ( cls , value , values ): \"\"\"Get password from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"PASS\" , \"postgres\" ) if value is None else value )","title":"validate_password()"},{"location":"reference/data/__init__/#now8_api.data.database.SqlEngine.__pydantic_model__.validate_port","text":"Get port from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"port\" , always = True ) @classmethod def validate_port ( cls , value , values ): \"\"\"Get port from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"PORT\" , \"5432\" ) if value is None else value )","title":"validate_port()"},{"location":"reference/data/__init__/#now8_api.data.database.SqlEngine.__pydantic_model__.validate_user","text":"Get user from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"user\" , always = True ) @classmethod def validate_user ( cls , value , values ): \"\"\"Get user from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"USER\" , \"postgres\" ) if value is None else value )","title":"validate_user()"},{"location":"reference/data/__init__/#now8_api.data.database.SqlEngine.execute_query","text":"Return the result of executing the passed query. Parameters: Name Type Description Default query str Query to perform. required args Query arguments. () Returns: Type Description List[tuple] The result of executing the passed query. Source code in now8_api/data/database/__init__.py @abstractmethod async def execute_query ( self , query : str , * args ) -> List [ tuple ]: \"\"\"Return the result of executing the passed query. Arguments: query: Query to perform. args: Query arguments. Returns: The result of executing the passed query. \"\"\"","title":"execute_query()"},{"location":"reference/data/__init__/#now8_api.data.database.SqlEngine.get_db_conf","text":"Return the database connection parameters. Returns: Type Description Dict[str, str] Dictionary with the available database connection parameters. Source code in now8_api/data/database/__init__.py def get_db_conf ( self ) -> Dict [ str , str ]: \"\"\"Return the database connection parameters. Returns: Dictionary with the available database connection parameters. \"\"\" return { \"dbname\" : str ( self . name ), \"user\" : str ( self . user ), \"password\" : str ( self . password ), \"host\" : str ( self . host ), \"port\" : str ( self . port ), }","title":"get_db_conf()"},{"location":"reference/data/__init__/#now8_api.data.database.SqlEngine.validate_host","text":"Get host from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"host\" , always = True ) @classmethod def validate_host ( cls , value , values ): \"\"\"Get host from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"HOST\" , \"postgres\" ) if value is None else value )","title":"validate_host()"},{"location":"reference/data/__init__/#now8_api.data.database.SqlEngine.validate_name","text":"Get name from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"name\" , always = True ) @classmethod def validate_name ( cls , value , values ): \"\"\"Get name from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"NAME\" , \"postgres\" ) if value is None else value )","title":"validate_name()"},{"location":"reference/data/__init__/#now8_api.data.database.SqlEngine.validate_password","text":"Get password from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"password\" , always = True ) @classmethod def validate_password ( cls , value , values ): \"\"\"Get password from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"PASS\" , \"postgres\" ) if value is None else value )","title":"validate_password()"},{"location":"reference/data/__init__/#now8_api.data.database.SqlEngine.validate_port","text":"Get port from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"port\" , always = True ) @classmethod def validate_port ( cls , value , values ): \"\"\"Get port from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"PORT\" , \"5432\" ) if value is None else value )","title":"validate_port()"},{"location":"reference/data/__init__/#now8_api.data.database.SqlEngine.validate_user","text":"Get user from environment variable if undefined. Source code in now8_api/data/database/__init__.py @validator ( \"user\" , always = True ) @classmethod def validate_user ( cls , value , values ): \"\"\"Get user from environment variable if undefined.\"\"\" return ( environ . get ( values [ \"env_prefix\" ] + \"USER\" , \"postgres\" ) if value is None else value )","title":"validate_user()"},{"location":"reference/data/__init__/#now8_api.data.database.postgres","text":"Module to store the PostgreSQL engine.","title":"postgres"},{"location":"reference/data/__init__/#now8_api.data.database.postgres.PostgresqlSqlEngine","text":"PostgreSQL engine class.","title":"PostgresqlSqlEngine"},{"location":"reference/data/__init__/#now8_api.data.database.postgres.PostgresqlSqlEngine.execute_query","text":"Return the result of executing the passed query. Parameters: Name Type Description Default query str Query to perform. required Returns: Type Description List The result of executing the passed query. Source code in now8_api/data/database/postgres.py @retry ( stop = stop_after_attempt ( 3 )) async def execute_query ( self , query : str , * args ) -> List : \"\"\"Return the result of executing the passed query. Arguments: query: Query to perform. Returns: The result of executing the passed query. \"\"\" db_conf = self . get_db_conf () db_conf [ \"database\" ] = db_conf . pop ( \"dbname\" ) try : conn = await asyncpg . connect ( ** db_conf , timeout = 3 ) except socket . gaierror as error : raise ConnectionError ( f \"Can't connect to database: { db_conf } .\" ) from error query_result = await conn . fetch ( query , * args ) await conn . close () return query_result","title":"execute_query()"},{"location":"reference/entrypoints/__init__/","text":"Module to store the entrypoints. api special Module to store the HTTP REST API. dependencies Module to store the endpoint parameter dependencies. main Main API.","title":"  init  "},{"location":"reference/entrypoints/__init__/#now8_api.entrypoints.api","text":"Module to store the HTTP REST API.","title":"api"},{"location":"reference/entrypoints/__init__/#now8_api.entrypoints.api.dependencies","text":"Module to store the endpoint parameter dependencies.","title":"dependencies"},{"location":"reference/entrypoints/__init__/#now8_api.entrypoints.api.main","text":"Main API.","title":"main"},{"location":"reference/entrypoints/api/__init__/","text":"Module to store the HTTP REST API. dependencies Module to store the endpoint parameter dependencies. main Main API.","title":"  init  "},{"location":"reference/entrypoints/api/__init__/#now8_api.entrypoints.api.dependencies","text":"Module to store the endpoint parameter dependencies.","title":"dependencies"},{"location":"reference/entrypoints/api/__init__/#now8_api.entrypoints.api.main","text":"Main API.","title":"main"},{"location":"reference/service/__init__/","text":"Module to store common service functions. CityNameError Invalid city name error. __init__ ( self , city_name ) special Set the error message and raise the exception. Parameters: Name Type Description Default city_name str Invalid city name passed. required Source code in now8_api/service/__init__.py def __init__ ( self , city_name : str ): \"\"\"Set the error message and raise the exception. Arguments: city_name: Invalid city name passed. \"\"\" message = f \"Invalid city name ' { city_name } '.\" super () . __init__ ( message ) StopIdError Invalid stop ID error. __init__ ( self , stop_id ) special Set the error message and raise the exception. Parameters: Name Type Description Default stop_id str Invalid stop identifier passed. required Source code in now8_api/service/__init__.py def __init__ ( self , stop_id : str ): \"\"\"Set the error message and raise the exception. Arguments: stop_id: Invalid stop identifier passed. \"\"\" message = f \"Invalid stop ID ' { stop_id } '.\" super () . __init__ ( message ) TransportTypeError Invalid transport type error. __init__ ( self , transport_type ) special Set the error message and raise the exception. Parameters: Name Type Description Default transport_type str Invalid transport type passed. required Source code in now8_api/service/__init__.py def __init__ ( self , transport_type : str ): \"\"\"Set the error message and raise the exception. Arguments: transport_type: Invalid transport type passed. \"\"\" message = f \"Invalid transport type ' { transport_type } '.\" super () . __init__ ( message ) city_data special Module to store the common classes and functions for all cities. CityData pydantic-model City data abstract class. Abstracts the city data retrieval. get_estimations ( self , stop ) async Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[now8_api.domain.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. UpstreamError If the upstream city API fails. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: \"\"\"Return ETA for the next vehicles to the stop. Arguments: stop: Stop to get the next vehicle arrival estimations for. Returns: ETA for the next vehicles to the stop. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. UpstreamError: If the upstream city API fails. \"\"\" get_routes_stop ( self , stop ) async Return all the routes that pass through the stop. Parameters: Name Type Description Default stop Stop Transport stop to get the routes for. required Returns: Type Description List[now8_api.domain.Route] Routes that pass through the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_routes_stop ( self , stop : Stop , ) -> List [ Route ]: \"\"\"Return all the routes that pass through the stop. Arguments: stop: Transport stop to get the routes for. Returns: Routes that pass through the stop. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. \"\"\" get_stops_city ( self , transport_types = None ) async Return all the stops of the selected transport types. Parameters: Name Type Description Default transport_types List[now8_api.domain.TransportType] Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. None Returns: Type Description List[now8_api.domain.Stop] All the stops of the selected transport types. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_stops_city ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: \"\"\"Return all the stops of the selected transport types. Arguments: transport_types: Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. Returns: All the stops of the selected transport types. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. \"\"\" get_stops_route ( self , route ) async Return all the stops of the selected route. Parameters: Name Type Description Default route Route Transport route to get the stops for. required Returns: Type Description Tuple[List[now8_api.domain.Stop], List[now8_api.domain.Stop]] Stops of the selected route for both ways in order. Exceptions: Type Description NotImplementedError If the method is not implemented for the route transport type in this city. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_stops_route ( self , route : Route , ) -> Tuple [ List [ Stop ], List [ Stop ]]: \"\"\"Return all the stops of the selected route. Arguments: route: Transport route to get the stops for. Returns: Stops of the selected route for both ways in order. Raises: NotImplementedError: If the method is not implemented for the route transport type in this city. \"\"\" UpstreamError Custom exception for upstream API fauilures. __init__ ( self , message ) special Initialization method. Parameters: Name Type Description Default message Error message. required Source code in now8_api/service/city_data/__init__.py def __init__ ( self , message ): \"\"\"Initialization method. Arguments: message: Error message. \"\"\" super () . __init__ ( message ) get_json ( url ) async Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: Type Description dict List of dictionaries with the parsed answer. Source code in now8_api/service/city_data/__init__.py @retry ( retry = ( retry_if_exception_type ( TimeoutError ) | retry_if_exception_type ( aiohttp . ClientResponseError ) ), stop = stop_after_attempt ( 3 ), wait = wait_exponential ( multiplier = 0.5 ), ) @validate_arguments async def get_json ( url : HttpUrl ) -> dict : \"\"\"Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: List of dictionaries with the parsed answer. \"\"\" async with aiohttp . ClientSession () as session : async with session . get ( url , raise_for_status = True , timeout = 10 , ) as resp : return await resp . json ( content_type = None ) madrid Module to store the city data of Madrid. MadridCityData pydantic-model Madrid city data. get_estimations ( self , stop ) async Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[now8_api.domain.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. UpstreamError If the upstream city API fails. Source code in now8_api/service/city_data/madrid.py @overrides async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: try : response = await get_json ( f \"https://www.crtm.es/\" # type: ignore f \"widgets/api/GetStopsTimes.php\" f \"?codStop=\" f \" { stop . id . removeprefix ( 'par_' ) . removeprefix ( 'est_' ) } &\" f \"type=1&orderBy=2&stopTimesByIti=3\" ) except Exception as error : raise UpstreamError ( \"Upstream error. Check the stop id or try later.\" ) from error result : List [ VehicleEstimation ] = [] for estimation in response [ \"stopTimes\" ][ \"times\" ] . get ( \"Time\" , []): vehicle = Vehicle ( id = estimation [ \"codIssue\" ], route_id = estimation [ \"line\" ][ \"codLine\" ], route_way = Way ( estimation [ \"direction\" ]) if estimation [ \"direction\" ] in [ 0 , 1 ] else None , ) estimation = Estimation ( estimation = estimation [ \"time\" ], time = response [ \"stopTimes\" ][ \"actualDate\" ], ) result . append ( VehicleEstimation ( vehicle = vehicle , estimation = estimation ) ) return result get_routes_stop ( self , stop ) async Return all the routes that pass through the stop. Parameters: Name Type Description Default stop Stop Transport stop to get the routes for. required Returns: Type Description List[now8_api.domain.Route] Routes that pass through the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_routes_stop ( self , stop : Stop , ) -> List [ Route ]: raise NotImplementedError get_stops_city ( self , transport_types = None ) async Return all the stops of the selected transport types. Parameters: Name Type Description Default transport_types List[now8_api.domain.TransportType] Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. None Returns: Type Description List[now8_api.domain.Stop] All the stops of the selected transport types. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_stops_city ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: raise NotImplementedError get_stops_route ( self , route ) async Return all the stops of the selected route. Parameters: Name Type Description Default route Route Transport route to get the stops for. required Returns: Type Description Tuple[List[now8_api.domain.Stop], List[now8_api.domain.Stop]] Stops of the selected route for both ways in order. Exceptions: Type Description NotImplementedError If the method is not implemented for the route transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_stops_route ( self , route : Route , ) -> Tuple [ List [ Stop ], List [ Stop ]]: raise NotImplementedError _stop_id_api ( stop_id_user , transport_type ) private Return the Stop ID in the API format. Parameters: Name Type Description Default stop_id_user str Stop ID in the user format. required transport_type TransportType Stop transport type. required Returns: Type Description str Stop ID in the API format. Exceptions: Type Description TransportTypeError If the transport type is not supported. Source code in now8_api/service/city_data/madrid.py def _stop_id_api ( stop_id_user : str , transport_type : TransportType ) -> str : \"\"\"Return the Stop ID in the API format. Arguments: stop_id_user: Stop ID in the user format. transport_type: Stop transport type. Returns: Stop ID in the API format. Raises: TransportTypeError: If the transport type is not supported. \"\"\" if transport_type not in TRANSPORT_TYPE_STOP_PREFIXES : raise TransportTypeError ( transport_type = transport_type . name ) return TRANSPORT_TYPE_STOP_PREFIXES [ transport_type ] + stop_id_user _stop_id_user ( stop_id_api , transport_type ) private Return the Stop ID in the user format. Parameters: Name Type Description Default stop_id_api str Stop ID in the city API format. required transport_type TransportType Stop transport type. required Returns: Type Description str Stop ID in the user format. Exceptions: Type Description TransportTypeError If the transport type is not supported. Source code in now8_api/service/city_data/madrid.py def _stop_id_user ( stop_id_api : str , transport_type : TransportType ) -> str : \"\"\"Return the Stop ID in the user format. Arguments: stop_id_api: Stop ID in the city API format. transport_type: Stop transport type. Returns: Stop ID in the user format. Raises: TransportTypeError: If the transport type is not supported. \"\"\" if transport_type not in TRANSPORT_TYPE_STOP_PREFIXES : raise TransportTypeError ( transport_type = transport_type . name ) return stop_id_api . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ transport_type ] ) route_service Module to store the main service functions. RouteNotFoundError Custom exception for route not found. __init__ ( self , route_id ) special Initialize ValueError with custom message. Parameters: Name Type Description Default route_id str Route ID that was not found. required Source code in now8_api/service/route_service.py def __init__ ( self , route_id : str ) -> None : \"\"\"Initialize ValueError with custom message. Arguments: route_id: Route ID that was not found. \"\"\" super () . __init__ ( f 'Route \" { route_id } \" not found.' ) RouteService pydantic-model all_routes ( self ) async Return all the routes of the city. Returns: Type Description Dict[str, Dict[str, Union[str, float, dict]]] List of dictionaries with the route ID, transport type, way, name, coordinates and zone of each route. Source code in now8_api/service/route_service.py async def all_routes ( self , ) -> Dict [ str , Dict [ str , Union [ str , float , dict ]]]: \"\"\"Return all the routes of the city. Returns: List of dictionaries with the route ID, transport type, way, name, coordinates and zone of each route. \"\"\" if self . routes_cache is None : await self . initialize_routes_cache () return self . routes_cache initialize_routes_cache ( self ) async Initialize routes_cache if undefined. Source code in now8_api/service/route_service.py async def initialize_routes_cache ( self ) -> None : \"\"\"Initialize `routes_cache` if undefined.\"\"\" table_routes : Table = Table ( \"routes\" ) query : Query = ( Query . from_ ( table_routes ) . select ( table_routes . route_id , table_routes . route_short_name , table_routes . route_long_name , table_routes . route_type , table_routes . route_color , ) . distinct () ) query_result : List [ tuple ] = await self . sql_engine . execute_query ( str ( query ) ) result : Dict [ str , Dict [ str , Union [ str , float , dict ]]] = {} for row in query_result : route_id : str = row [ 0 ] route_code : str = row [ 1 ] route_name : str = row [ 2 ] route_type : int = row [ 3 ] route_color : str = row [ 4 ] route = Route ( id = route_id , code = route_code , name = route_name , transport_type = TransportType ( route_type ), color = Color ( route_color ), ) result [ route . id ] = { \"id\" : route . id , \"code\" : route . code , \"name\" : route . name , \"transport_type\" : route . transport_type . value , \"color\" : str ( route . color . original ()), } self . routes_cache = result route_info ( self , route_id ) async Return the route information. Parameters: Name Type Description Default route_id str Route identifier. required Returns: Type Description Dict[str, Union[str, float]] Dictionary with the route ID, transport type, way, name, coordinates and zone. Exceptions: Type Description RouteNotFoundError If the route_id does not match any route. Source code in now8_api/service/route_service.py async def route_info ( self , route_id : str ) -> Dict [ str , Union [ str , float ]]: \"\"\"Return the route information. Arguments: route_id: Route identifier. Returns: Dictionary with the route ID, transport type, way, name, coordinates and zone. Raises: RouteNotFoundError: If the `route_id` does not match any route. \"\"\" if self . routes_cache is None : await self . initialize_routes_cache () try : return self . routes_cache [ route_id ] except KeyError as error : raise RouteNotFoundError ( route_id = route_id ) from error service Module to store the main service functions. Cities Enum with the available cities. Service pydantic-model Service base class. Attributes: Name Type Description sql_engine SqlEngine SqlEngine instance for the city. exclude ( dict_of_dicts , keys_to_exclude ) Filter out keys of nested dictionaries (second level). Parameters: Name Type Description Default dict_of_dicts Dict[Any, Dict[str, Any]] Nested dictionaries. required keys_to_exclude List[str] List with the keys to exclude. required Returns: Type Description Dict[Any, Dict[str, Any]] Original nested dictionary except the entries with a key in keys_to_exclude of the second level of dictionaries. Source code in now8_api/service/service.py def exclude ( dict_of_dicts : Dict [ Any , Dict [ str , Any ]], keys_to_exclude : List [ str ] ) -> Dict [ Any , Dict [ str , Any ]]: \"\"\"Filter out keys of nested dictionaries (second level). Arguments: dict_of_dicts: Nested dictionaries. keys_to_exclude: List with the keys to exclude. Returns: Original nested dictionary except the entries with a key in `keys_to_exclude` of the second level of dictionaries. \"\"\" if keys_to_exclude is not None : return { key : dict ( filter ( lambda key_value : key_value [ 0 ] not in keys_to_exclude , value . items (), ) ) for key , value in dict_of_dicts . items () } return dict_of_dicts stop_service StopNotFoundError Custom exception for stop not found. __init__ ( self , stop_id ) special Initialize ValueError with custom message. Parameters: Name Type Description Default stop_id str Stop ID that was not found. required Source code in now8_api/service/stop_service.py def __init__ ( self , stop_id : str ) -> None : \"\"\"Initialize ValueError with custom message. Arguments: stop_id: Stop ID that was not found. \"\"\" super () . __init__ ( f 'Stop \" { stop_id } \" not found.' ) StopService pydantic-model Service base class. Attributes: Name Type Description city_data CityData CityData instance for the city. stops_cache Dict[str, Dict[str, Any]] Object to store the stops info. all_stops ( self ) async Return all the stops of the city. Returns: Type Description Dict[str, Dict[str, Union[str, float, dict]]] List of dictionaries with the stop ID, transport type, way, name, coordinates and zone of each stop. Source code in now8_api/service/stop_service.py async def all_stops ( self , ) -> Dict [ str , Dict [ str , Union [ str , float , dict ]]]: \"\"\"Return all the stops of the city. Returns: List of dictionaries with the stop ID, transport type, way, name, coordinates and zone of each stop. \"\"\" if self . stops_cache is None : await self . initialize_stops_cache () return self . stops_cache initialize_stops_cache ( self ) async Initialize stops_cache if undefined. Source code in now8_api/service/stop_service.py async def initialize_stops_cache ( self ) -> None : \"\"\"Initialize `stops_cache` if undefined.\"\"\" table_routes : Table = Table ( \"routes\" ) table_route_stops : Table = Table ( \"route_stops\" ) table_stops : Table = Table ( \"stops\" ) query : Query = ( Query . from_ ( table_routes ) . join ( table_route_stops ) . on ( table_routes . route_id == table_route_stops . route_id ) . join ( table_stops ) . on ( table_route_stops . stop_id == table_stops . stop_id ) . select ( table_stops . stop_id , table_stops . stop_code , table_stops . stop_name , table_stops . stop_lat , table_stops . stop_lon , table_stops . zone_id , table_routes . route_id , table_route_stops . direction_id , ) . distinct () ) query_result : List [ tuple ] = await self . sql_engine . execute_query ( str ( query ) ) result : Dict [ str , Dict [ str , Any ]] = {} for row in query_result : stop_id : str = row [ 0 ] stop_code : str = row [ 1 ] stop_name : str = row [ 2 ] stop_lat : float = row [ 3 ] stop_lon : float = row [ 4 ] stop_zone : str = row [ 5 ] if stop_id not in result : stop = Stop ( id = stop_id , code = stop_code , name = stop_name , coordinates = Coordinates ( latitude = stop_lat , longitude = stop_lon ), zone = stop_zone , ) result [ stop . id ] = { \"id\" : stop . id , \"code\" : stop . code , \"name\" : stop . name , \"longitude\" : stop . coordinates . longitude , \"latitude\" : stop . coordinates . latitude , \"zone\" : stop . zone , \"route_ways\" : [], } route_id : str = row [ 6 ] route_way : int = row [ 7 ] result [ stop . id ][ \"route_ways\" ] . append ( { \"id\" : route_id , \"way\" : route_way } ) self . stops_cache = result stop_estimation ( self , stop_id ) async Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop_id str Stop identifier. required Returns: Type Description List[Dict[str, dict]] ETA for the next vehicles to the stop. Source code in now8_api/service/stop_service.py async def stop_estimation ( self , stop_id : str ) -> List [ Dict [ str , dict ]]: \"\"\"Return ETA for the next vehicles to the stop. Arguments: stop_id: Stop identifier. Returns: ETA for the next vehicles to the stop. \"\"\" stop = Stop ( id = stop_id , transport_type = TransportType . INTERCITY_BUS ) estimations = await self . city_data . get_estimations ( stop ) result : List [ Dict [ str , dict ]] = [ { \"vehicle\" : { \"id\" : v_e . vehicle . id , \"route_way\" : { \"id\" : v_e . vehicle . route_id , \"way\" : v_e . vehicle . route_way . value if v_e . vehicle . route_way is not None else None , }, }, \"estimation\" : { \"estimation\" : v_e . estimation . estimation , \"time\" : v_e . estimation . time , }, } for v_e in estimations ] return result stop_info ( self , stop_id ) async Return the stop information. Parameters: Name Type Description Default stop_id str Stop identifier. required Returns: Type Description Dict[str, Union[str, float, list]] Dictionary with the stop ID, transport type, way, name, coordinates and zone. Exceptions: Type Description StopNotFoundError If the stop_id does not match any stop. Source code in now8_api/service/stop_service.py async def stop_info ( self , stop_id : str ) -> Dict [ str , Union [ str , float , list ]]: \"\"\"Return the stop information. Arguments: stop_id: Stop identifier. Returns: Dictionary with the stop ID, transport type, way, name, coordinates and zone. Raises: StopNotFoundError: If the `stop_id` does not match any stop. \"\"\" if self . stops_cache is None : await self . initialize_stops_cache () try : return self . stops_cache [ stop_id ] except KeyError as error : raise StopNotFoundError ( stop_id = stop_id ) from error","title":"  init  "},{"location":"reference/service/__init__/#now8_api.service.CityNameError","text":"Invalid city name error.","title":"CityNameError"},{"location":"reference/service/__init__/#now8_api.service.CityNameError.__init__","text":"Set the error message and raise the exception. Parameters: Name Type Description Default city_name str Invalid city name passed. required Source code in now8_api/service/__init__.py def __init__ ( self , city_name : str ): \"\"\"Set the error message and raise the exception. Arguments: city_name: Invalid city name passed. \"\"\" message = f \"Invalid city name ' { city_name } '.\" super () . __init__ ( message )","title":"__init__()"},{"location":"reference/service/__init__/#now8_api.service.StopIdError","text":"Invalid stop ID error.","title":"StopIdError"},{"location":"reference/service/__init__/#now8_api.service.StopIdError.__init__","text":"Set the error message and raise the exception. Parameters: Name Type Description Default stop_id str Invalid stop identifier passed. required Source code in now8_api/service/__init__.py def __init__ ( self , stop_id : str ): \"\"\"Set the error message and raise the exception. Arguments: stop_id: Invalid stop identifier passed. \"\"\" message = f \"Invalid stop ID ' { stop_id } '.\" super () . __init__ ( message )","title":"__init__()"},{"location":"reference/service/__init__/#now8_api.service.TransportTypeError","text":"Invalid transport type error.","title":"TransportTypeError"},{"location":"reference/service/__init__/#now8_api.service.TransportTypeError.__init__","text":"Set the error message and raise the exception. Parameters: Name Type Description Default transport_type str Invalid transport type passed. required Source code in now8_api/service/__init__.py def __init__ ( self , transport_type : str ): \"\"\"Set the error message and raise the exception. Arguments: transport_type: Invalid transport type passed. \"\"\" message = f \"Invalid transport type ' { transport_type } '.\" super () . __init__ ( message )","title":"__init__()"},{"location":"reference/service/__init__/#now8_api.service.city_data","text":"Module to store the common classes and functions for all cities.","title":"city_data"},{"location":"reference/service/__init__/#now8_api.service.city_data.CityData","text":"City data abstract class. Abstracts the city data retrieval.","title":"CityData"},{"location":"reference/service/__init__/#now8_api.service.city_data.CityData.get_estimations","text":"Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[now8_api.domain.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. UpstreamError If the upstream city API fails. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: \"\"\"Return ETA for the next vehicles to the stop. Arguments: stop: Stop to get the next vehicle arrival estimations for. Returns: ETA for the next vehicles to the stop. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. UpstreamError: If the upstream city API fails. \"\"\"","title":"get_estimations()"},{"location":"reference/service/__init__/#now8_api.service.city_data.CityData.get_routes_stop","text":"Return all the routes that pass through the stop. Parameters: Name Type Description Default stop Stop Transport stop to get the routes for. required Returns: Type Description List[now8_api.domain.Route] Routes that pass through the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_routes_stop ( self , stop : Stop , ) -> List [ Route ]: \"\"\"Return all the routes that pass through the stop. Arguments: stop: Transport stop to get the routes for. Returns: Routes that pass through the stop. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. \"\"\"","title":"get_routes_stop()"},{"location":"reference/service/__init__/#now8_api.service.city_data.CityData.get_stops_city","text":"Return all the stops of the selected transport types. Parameters: Name Type Description Default transport_types List[now8_api.domain.TransportType] Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. None Returns: Type Description List[now8_api.domain.Stop] All the stops of the selected transport types. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_stops_city ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: \"\"\"Return all the stops of the selected transport types. Arguments: transport_types: Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. Returns: All the stops of the selected transport types. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. \"\"\"","title":"get_stops_city()"},{"location":"reference/service/__init__/#now8_api.service.city_data.CityData.get_stops_route","text":"Return all the stops of the selected route. Parameters: Name Type Description Default route Route Transport route to get the stops for. required Returns: Type Description Tuple[List[now8_api.domain.Stop], List[now8_api.domain.Stop]] Stops of the selected route for both ways in order. Exceptions: Type Description NotImplementedError If the method is not implemented for the route transport type in this city. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_stops_route ( self , route : Route , ) -> Tuple [ List [ Stop ], List [ Stop ]]: \"\"\"Return all the stops of the selected route. Arguments: route: Transport route to get the stops for. Returns: Stops of the selected route for both ways in order. Raises: NotImplementedError: If the method is not implemented for the route transport type in this city. \"\"\"","title":"get_stops_route()"},{"location":"reference/service/__init__/#now8_api.service.city_data.UpstreamError","text":"Custom exception for upstream API fauilures.","title":"UpstreamError"},{"location":"reference/service/__init__/#now8_api.service.city_data.UpstreamError.__init__","text":"Initialization method. Parameters: Name Type Description Default message Error message. required Source code in now8_api/service/city_data/__init__.py def __init__ ( self , message ): \"\"\"Initialization method. Arguments: message: Error message. \"\"\" super () . __init__ ( message )","title":"__init__()"},{"location":"reference/service/__init__/#now8_api.service.city_data.get_json","text":"Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: Type Description dict List of dictionaries with the parsed answer. Source code in now8_api/service/city_data/__init__.py @retry ( retry = ( retry_if_exception_type ( TimeoutError ) | retry_if_exception_type ( aiohttp . ClientResponseError ) ), stop = stop_after_attempt ( 3 ), wait = wait_exponential ( multiplier = 0.5 ), ) @validate_arguments async def get_json ( url : HttpUrl ) -> dict : \"\"\"Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: List of dictionaries with the parsed answer. \"\"\" async with aiohttp . ClientSession () as session : async with session . get ( url , raise_for_status = True , timeout = 10 , ) as resp : return await resp . json ( content_type = None )","title":"get_json()"},{"location":"reference/service/__init__/#now8_api.service.city_data.madrid","text":"Module to store the city data of Madrid.","title":"madrid"},{"location":"reference/service/__init__/#now8_api.service.city_data.madrid.MadridCityData","text":"Madrid city data.","title":"MadridCityData"},{"location":"reference/service/__init__/#now8_api.service.city_data.madrid.MadridCityData.get_estimations","text":"Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[now8_api.domain.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. UpstreamError If the upstream city API fails. Source code in now8_api/service/city_data/madrid.py @overrides async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: try : response = await get_json ( f \"https://www.crtm.es/\" # type: ignore f \"widgets/api/GetStopsTimes.php\" f \"?codStop=\" f \" { stop . id . removeprefix ( 'par_' ) . removeprefix ( 'est_' ) } &\" f \"type=1&orderBy=2&stopTimesByIti=3\" ) except Exception as error : raise UpstreamError ( \"Upstream error. Check the stop id or try later.\" ) from error result : List [ VehicleEstimation ] = [] for estimation in response [ \"stopTimes\" ][ \"times\" ] . get ( \"Time\" , []): vehicle = Vehicle ( id = estimation [ \"codIssue\" ], route_id = estimation [ \"line\" ][ \"codLine\" ], route_way = Way ( estimation [ \"direction\" ]) if estimation [ \"direction\" ] in [ 0 , 1 ] else None , ) estimation = Estimation ( estimation = estimation [ \"time\" ], time = response [ \"stopTimes\" ][ \"actualDate\" ], ) result . append ( VehicleEstimation ( vehicle = vehicle , estimation = estimation ) ) return result","title":"get_estimations()"},{"location":"reference/service/__init__/#now8_api.service.city_data.madrid.MadridCityData.get_routes_stop","text":"Return all the routes that pass through the stop. Parameters: Name Type Description Default stop Stop Transport stop to get the routes for. required Returns: Type Description List[now8_api.domain.Route] Routes that pass through the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_routes_stop ( self , stop : Stop , ) -> List [ Route ]: raise NotImplementedError","title":"get_routes_stop()"},{"location":"reference/service/__init__/#now8_api.service.city_data.madrid.MadridCityData.get_stops_city","text":"Return all the stops of the selected transport types. Parameters: Name Type Description Default transport_types List[now8_api.domain.TransportType] Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. None Returns: Type Description List[now8_api.domain.Stop] All the stops of the selected transport types. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_stops_city ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: raise NotImplementedError","title":"get_stops_city()"},{"location":"reference/service/__init__/#now8_api.service.city_data.madrid.MadridCityData.get_stops_route","text":"Return all the stops of the selected route. Parameters: Name Type Description Default route Route Transport route to get the stops for. required Returns: Type Description Tuple[List[now8_api.domain.Stop], List[now8_api.domain.Stop]] Stops of the selected route for both ways in order. Exceptions: Type Description NotImplementedError If the method is not implemented for the route transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_stops_route ( self , route : Route , ) -> Tuple [ List [ Stop ], List [ Stop ]]: raise NotImplementedError","title":"get_stops_route()"},{"location":"reference/service/__init__/#now8_api.service.city_data.madrid._stop_id_api","text":"Return the Stop ID in the API format. Parameters: Name Type Description Default stop_id_user str Stop ID in the user format. required transport_type TransportType Stop transport type. required Returns: Type Description str Stop ID in the API format. Exceptions: Type Description TransportTypeError If the transport type is not supported. Source code in now8_api/service/city_data/madrid.py def _stop_id_api ( stop_id_user : str , transport_type : TransportType ) -> str : \"\"\"Return the Stop ID in the API format. Arguments: stop_id_user: Stop ID in the user format. transport_type: Stop transport type. Returns: Stop ID in the API format. Raises: TransportTypeError: If the transport type is not supported. \"\"\" if transport_type not in TRANSPORT_TYPE_STOP_PREFIXES : raise TransportTypeError ( transport_type = transport_type . name ) return TRANSPORT_TYPE_STOP_PREFIXES [ transport_type ] + stop_id_user","title":"_stop_id_api()"},{"location":"reference/service/__init__/#now8_api.service.city_data.madrid._stop_id_user","text":"Return the Stop ID in the user format. Parameters: Name Type Description Default stop_id_api str Stop ID in the city API format. required transport_type TransportType Stop transport type. required Returns: Type Description str Stop ID in the user format. Exceptions: Type Description TransportTypeError If the transport type is not supported. Source code in now8_api/service/city_data/madrid.py def _stop_id_user ( stop_id_api : str , transport_type : TransportType ) -> str : \"\"\"Return the Stop ID in the user format. Arguments: stop_id_api: Stop ID in the city API format. transport_type: Stop transport type. Returns: Stop ID in the user format. Raises: TransportTypeError: If the transport type is not supported. \"\"\" if transport_type not in TRANSPORT_TYPE_STOP_PREFIXES : raise TransportTypeError ( transport_type = transport_type . name ) return stop_id_api . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ transport_type ] )","title":"_stop_id_user()"},{"location":"reference/service/__init__/#now8_api.service.route_service","text":"Module to store the main service functions.","title":"route_service"},{"location":"reference/service/__init__/#now8_api.service.route_service.RouteNotFoundError","text":"Custom exception for route not found.","title":"RouteNotFoundError"},{"location":"reference/service/__init__/#now8_api.service.route_service.RouteNotFoundError.__init__","text":"Initialize ValueError with custom message. Parameters: Name Type Description Default route_id str Route ID that was not found. required Source code in now8_api/service/route_service.py def __init__ ( self , route_id : str ) -> None : \"\"\"Initialize ValueError with custom message. Arguments: route_id: Route ID that was not found. \"\"\" super () . __init__ ( f 'Route \" { route_id } \" not found.' )","title":"__init__()"},{"location":"reference/service/__init__/#now8_api.service.route_service.RouteService","text":"","title":"RouteService"},{"location":"reference/service/__init__/#now8_api.service.route_service.RouteService.all_routes","text":"Return all the routes of the city. Returns: Type Description Dict[str, Dict[str, Union[str, float, dict]]] List of dictionaries with the route ID, transport type, way, name, coordinates and zone of each route. Source code in now8_api/service/route_service.py async def all_routes ( self , ) -> Dict [ str , Dict [ str , Union [ str , float , dict ]]]: \"\"\"Return all the routes of the city. Returns: List of dictionaries with the route ID, transport type, way, name, coordinates and zone of each route. \"\"\" if self . routes_cache is None : await self . initialize_routes_cache () return self . routes_cache","title":"all_routes()"},{"location":"reference/service/__init__/#now8_api.service.route_service.RouteService.initialize_routes_cache","text":"Initialize routes_cache if undefined. Source code in now8_api/service/route_service.py async def initialize_routes_cache ( self ) -> None : \"\"\"Initialize `routes_cache` if undefined.\"\"\" table_routes : Table = Table ( \"routes\" ) query : Query = ( Query . from_ ( table_routes ) . select ( table_routes . route_id , table_routes . route_short_name , table_routes . route_long_name , table_routes . route_type , table_routes . route_color , ) . distinct () ) query_result : List [ tuple ] = await self . sql_engine . execute_query ( str ( query ) ) result : Dict [ str , Dict [ str , Union [ str , float , dict ]]] = {} for row in query_result : route_id : str = row [ 0 ] route_code : str = row [ 1 ] route_name : str = row [ 2 ] route_type : int = row [ 3 ] route_color : str = row [ 4 ] route = Route ( id = route_id , code = route_code , name = route_name , transport_type = TransportType ( route_type ), color = Color ( route_color ), ) result [ route . id ] = { \"id\" : route . id , \"code\" : route . code , \"name\" : route . name , \"transport_type\" : route . transport_type . value , \"color\" : str ( route . color . original ()), } self . routes_cache = result","title":"initialize_routes_cache()"},{"location":"reference/service/__init__/#now8_api.service.route_service.RouteService.route_info","text":"Return the route information. Parameters: Name Type Description Default route_id str Route identifier. required Returns: Type Description Dict[str, Union[str, float]] Dictionary with the route ID, transport type, way, name, coordinates and zone. Exceptions: Type Description RouteNotFoundError If the route_id does not match any route. Source code in now8_api/service/route_service.py async def route_info ( self , route_id : str ) -> Dict [ str , Union [ str , float ]]: \"\"\"Return the route information. Arguments: route_id: Route identifier. Returns: Dictionary with the route ID, transport type, way, name, coordinates and zone. Raises: RouteNotFoundError: If the `route_id` does not match any route. \"\"\" if self . routes_cache is None : await self . initialize_routes_cache () try : return self . routes_cache [ route_id ] except KeyError as error : raise RouteNotFoundError ( route_id = route_id ) from error","title":"route_info()"},{"location":"reference/service/__init__/#now8_api.service.service","text":"Module to store the main service functions.","title":"service"},{"location":"reference/service/__init__/#now8_api.service.service.Cities","text":"Enum with the available cities.","title":"Cities"},{"location":"reference/service/__init__/#now8_api.service.service.Service","text":"Service base class. Attributes: Name Type Description sql_engine SqlEngine SqlEngine instance for the city.","title":"Service"},{"location":"reference/service/__init__/#now8_api.service.service.exclude","text":"Filter out keys of nested dictionaries (second level). Parameters: Name Type Description Default dict_of_dicts Dict[Any, Dict[str, Any]] Nested dictionaries. required keys_to_exclude List[str] List with the keys to exclude. required Returns: Type Description Dict[Any, Dict[str, Any]] Original nested dictionary except the entries with a key in keys_to_exclude of the second level of dictionaries. Source code in now8_api/service/service.py def exclude ( dict_of_dicts : Dict [ Any , Dict [ str , Any ]], keys_to_exclude : List [ str ] ) -> Dict [ Any , Dict [ str , Any ]]: \"\"\"Filter out keys of nested dictionaries (second level). Arguments: dict_of_dicts: Nested dictionaries. keys_to_exclude: List with the keys to exclude. Returns: Original nested dictionary except the entries with a key in `keys_to_exclude` of the second level of dictionaries. \"\"\" if keys_to_exclude is not None : return { key : dict ( filter ( lambda key_value : key_value [ 0 ] not in keys_to_exclude , value . items (), ) ) for key , value in dict_of_dicts . items () } return dict_of_dicts","title":"exclude()"},{"location":"reference/service/__init__/#now8_api.service.stop_service","text":"","title":"stop_service"},{"location":"reference/service/__init__/#now8_api.service.stop_service.StopNotFoundError","text":"Custom exception for stop not found.","title":"StopNotFoundError"},{"location":"reference/service/__init__/#now8_api.service.stop_service.StopNotFoundError.__init__","text":"Initialize ValueError with custom message. Parameters: Name Type Description Default stop_id str Stop ID that was not found. required Source code in now8_api/service/stop_service.py def __init__ ( self , stop_id : str ) -> None : \"\"\"Initialize ValueError with custom message. Arguments: stop_id: Stop ID that was not found. \"\"\" super () . __init__ ( f 'Stop \" { stop_id } \" not found.' )","title":"__init__()"},{"location":"reference/service/__init__/#now8_api.service.stop_service.StopService","text":"Service base class. Attributes: Name Type Description city_data CityData CityData instance for the city. stops_cache Dict[str, Dict[str, Any]] Object to store the stops info.","title":"StopService"},{"location":"reference/service/__init__/#now8_api.service.stop_service.StopService.all_stops","text":"Return all the stops of the city. Returns: Type Description Dict[str, Dict[str, Union[str, float, dict]]] List of dictionaries with the stop ID, transport type, way, name, coordinates and zone of each stop. Source code in now8_api/service/stop_service.py async def all_stops ( self , ) -> Dict [ str , Dict [ str , Union [ str , float , dict ]]]: \"\"\"Return all the stops of the city. Returns: List of dictionaries with the stop ID, transport type, way, name, coordinates and zone of each stop. \"\"\" if self . stops_cache is None : await self . initialize_stops_cache () return self . stops_cache","title":"all_stops()"},{"location":"reference/service/__init__/#now8_api.service.stop_service.StopService.initialize_stops_cache","text":"Initialize stops_cache if undefined. Source code in now8_api/service/stop_service.py async def initialize_stops_cache ( self ) -> None : \"\"\"Initialize `stops_cache` if undefined.\"\"\" table_routes : Table = Table ( \"routes\" ) table_route_stops : Table = Table ( \"route_stops\" ) table_stops : Table = Table ( \"stops\" ) query : Query = ( Query . from_ ( table_routes ) . join ( table_route_stops ) . on ( table_routes . route_id == table_route_stops . route_id ) . join ( table_stops ) . on ( table_route_stops . stop_id == table_stops . stop_id ) . select ( table_stops . stop_id , table_stops . stop_code , table_stops . stop_name , table_stops . stop_lat , table_stops . stop_lon , table_stops . zone_id , table_routes . route_id , table_route_stops . direction_id , ) . distinct () ) query_result : List [ tuple ] = await self . sql_engine . execute_query ( str ( query ) ) result : Dict [ str , Dict [ str , Any ]] = {} for row in query_result : stop_id : str = row [ 0 ] stop_code : str = row [ 1 ] stop_name : str = row [ 2 ] stop_lat : float = row [ 3 ] stop_lon : float = row [ 4 ] stop_zone : str = row [ 5 ] if stop_id not in result : stop = Stop ( id = stop_id , code = stop_code , name = stop_name , coordinates = Coordinates ( latitude = stop_lat , longitude = stop_lon ), zone = stop_zone , ) result [ stop . id ] = { \"id\" : stop . id , \"code\" : stop . code , \"name\" : stop . name , \"longitude\" : stop . coordinates . longitude , \"latitude\" : stop . coordinates . latitude , \"zone\" : stop . zone , \"route_ways\" : [], } route_id : str = row [ 6 ] route_way : int = row [ 7 ] result [ stop . id ][ \"route_ways\" ] . append ( { \"id\" : route_id , \"way\" : route_way } ) self . stops_cache = result","title":"initialize_stops_cache()"},{"location":"reference/service/__init__/#now8_api.service.stop_service.StopService.stop_estimation","text":"Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop_id str Stop identifier. required Returns: Type Description List[Dict[str, dict]] ETA for the next vehicles to the stop. Source code in now8_api/service/stop_service.py async def stop_estimation ( self , stop_id : str ) -> List [ Dict [ str , dict ]]: \"\"\"Return ETA for the next vehicles to the stop. Arguments: stop_id: Stop identifier. Returns: ETA for the next vehicles to the stop. \"\"\" stop = Stop ( id = stop_id , transport_type = TransportType . INTERCITY_BUS ) estimations = await self . city_data . get_estimations ( stop ) result : List [ Dict [ str , dict ]] = [ { \"vehicle\" : { \"id\" : v_e . vehicle . id , \"route_way\" : { \"id\" : v_e . vehicle . route_id , \"way\" : v_e . vehicle . route_way . value if v_e . vehicle . route_way is not None else None , }, }, \"estimation\" : { \"estimation\" : v_e . estimation . estimation , \"time\" : v_e . estimation . time , }, } for v_e in estimations ] return result","title":"stop_estimation()"},{"location":"reference/service/__init__/#now8_api.service.stop_service.StopService.stop_info","text":"Return the stop information. Parameters: Name Type Description Default stop_id str Stop identifier. required Returns: Type Description Dict[str, Union[str, float, list]] Dictionary with the stop ID, transport type, way, name, coordinates and zone. Exceptions: Type Description StopNotFoundError If the stop_id does not match any stop. Source code in now8_api/service/stop_service.py async def stop_info ( self , stop_id : str ) -> Dict [ str , Union [ str , float , list ]]: \"\"\"Return the stop information. Arguments: stop_id: Stop identifier. Returns: Dictionary with the stop ID, transport type, way, name, coordinates and zone. Raises: StopNotFoundError: If the `stop_id` does not match any stop. \"\"\" if self . stops_cache is None : await self . initialize_stops_cache () try : return self . stops_cache [ stop_id ] except KeyError as error : raise StopNotFoundError ( stop_id = stop_id ) from error","title":"stop_info()"},{"location":"reference/service/service/","text":"Module to store the main service functions. Cities Enum with the available cities. Service pydantic-model Service base class. Attributes: Name Type Description sql_engine SqlEngine SqlEngine instance for the city. exclude ( dict_of_dicts , keys_to_exclude ) Filter out keys of nested dictionaries (second level). Parameters: Name Type Description Default dict_of_dicts Dict[Any, Dict[str, Any]] Nested dictionaries. required keys_to_exclude List[str] List with the keys to exclude. required Returns: Type Description Dict[Any, Dict[str, Any]] Original nested dictionary except the entries with a key in keys_to_exclude of the second level of dictionaries. Source code in now8_api/service/service.py def exclude ( dict_of_dicts : Dict [ Any , Dict [ str , Any ]], keys_to_exclude : List [ str ] ) -> Dict [ Any , Dict [ str , Any ]]: \"\"\"Filter out keys of nested dictionaries (second level). Arguments: dict_of_dicts: Nested dictionaries. keys_to_exclude: List with the keys to exclude. Returns: Original nested dictionary except the entries with a key in `keys_to_exclude` of the second level of dictionaries. \"\"\" if keys_to_exclude is not None : return { key : dict ( filter ( lambda key_value : key_value [ 0 ] not in keys_to_exclude , value . items (), ) ) for key , value in dict_of_dicts . items () } return dict_of_dicts","title":"Service"},{"location":"reference/service/service/#now8_api.service.service.Cities","text":"Enum with the available cities.","title":"Cities"},{"location":"reference/service/service/#now8_api.service.service.Service","text":"Service base class. Attributes: Name Type Description sql_engine SqlEngine SqlEngine instance for the city.","title":"Service"},{"location":"reference/service/service/#now8_api.service.service.exclude","text":"Filter out keys of nested dictionaries (second level). Parameters: Name Type Description Default dict_of_dicts Dict[Any, Dict[str, Any]] Nested dictionaries. required keys_to_exclude List[str] List with the keys to exclude. required Returns: Type Description Dict[Any, Dict[str, Any]] Original nested dictionary except the entries with a key in keys_to_exclude of the second level of dictionaries. Source code in now8_api/service/service.py def exclude ( dict_of_dicts : Dict [ Any , Dict [ str , Any ]], keys_to_exclude : List [ str ] ) -> Dict [ Any , Dict [ str , Any ]]: \"\"\"Filter out keys of nested dictionaries (second level). Arguments: dict_of_dicts: Nested dictionaries. keys_to_exclude: List with the keys to exclude. Returns: Original nested dictionary except the entries with a key in `keys_to_exclude` of the second level of dictionaries. \"\"\" if keys_to_exclude is not None : return { key : dict ( filter ( lambda key_value : key_value [ 0 ] not in keys_to_exclude , value . items (), ) ) for key , value in dict_of_dicts . items () } return dict_of_dicts","title":"exclude()"},{"location":"reference/service/city_data/__init__/","text":"Module to store the common classes and functions for all cities. CityData pydantic-model City data abstract class. Abstracts the city data retrieval. get_estimations ( self , stop ) async Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[now8_api.domain.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. UpstreamError If the upstream city API fails. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: \"\"\"Return ETA for the next vehicles to the stop. Arguments: stop: Stop to get the next vehicle arrival estimations for. Returns: ETA for the next vehicles to the stop. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. UpstreamError: If the upstream city API fails. \"\"\" get_routes_stop ( self , stop ) async Return all the routes that pass through the stop. Parameters: Name Type Description Default stop Stop Transport stop to get the routes for. required Returns: Type Description List[now8_api.domain.Route] Routes that pass through the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_routes_stop ( self , stop : Stop , ) -> List [ Route ]: \"\"\"Return all the routes that pass through the stop. Arguments: stop: Transport stop to get the routes for. Returns: Routes that pass through the stop. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. \"\"\" get_stops_city ( self , transport_types = None ) async Return all the stops of the selected transport types. Parameters: Name Type Description Default transport_types List[now8_api.domain.TransportType] Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. None Returns: Type Description List[now8_api.domain.Stop] All the stops of the selected transport types. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_stops_city ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: \"\"\"Return all the stops of the selected transport types. Arguments: transport_types: Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. Returns: All the stops of the selected transport types. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. \"\"\" get_stops_route ( self , route ) async Return all the stops of the selected route. Parameters: Name Type Description Default route Route Transport route to get the stops for. required Returns: Type Description Tuple[List[now8_api.domain.Stop], List[now8_api.domain.Stop]] Stops of the selected route for both ways in order. Exceptions: Type Description NotImplementedError If the method is not implemented for the route transport type in this city. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_stops_route ( self , route : Route , ) -> Tuple [ List [ Stop ], List [ Stop ]]: \"\"\"Return all the stops of the selected route. Arguments: route: Transport route to get the stops for. Returns: Stops of the selected route for both ways in order. Raises: NotImplementedError: If the method is not implemented for the route transport type in this city. \"\"\" UpstreamError Custom exception for upstream API fauilures. __init__ ( self , message ) special Initialization method. Parameters: Name Type Description Default message Error message. required Source code in now8_api/service/city_data/__init__.py def __init__ ( self , message ): \"\"\"Initialization method. Arguments: message: Error message. \"\"\" super () . __init__ ( message ) get_json ( url ) async Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: Type Description dict List of dictionaries with the parsed answer. Source code in now8_api/service/city_data/__init__.py @retry ( retry = ( retry_if_exception_type ( TimeoutError ) | retry_if_exception_type ( aiohttp . ClientResponseError ) ), stop = stop_after_attempt ( 3 ), wait = wait_exponential ( multiplier = 0.5 ), ) @validate_arguments async def get_json ( url : HttpUrl ) -> dict : \"\"\"Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: List of dictionaries with the parsed answer. \"\"\" async with aiohttp . ClientSession () as session : async with session . get ( url , raise_for_status = True , timeout = 10 , ) as resp : return await resp . json ( content_type = None ) madrid Module to store the city data of Madrid. MadridCityData pydantic-model Madrid city data. get_estimations ( self , stop ) async Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[now8_api.domain.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. UpstreamError If the upstream city API fails. Source code in now8_api/service/city_data/madrid.py @overrides async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: try : response = await get_json ( f \"https://www.crtm.es/\" # type: ignore f \"widgets/api/GetStopsTimes.php\" f \"?codStop=\" f \" { stop . id . removeprefix ( 'par_' ) . removeprefix ( 'est_' ) } &\" f \"type=1&orderBy=2&stopTimesByIti=3\" ) except Exception as error : raise UpstreamError ( \"Upstream error. Check the stop id or try later.\" ) from error result : List [ VehicleEstimation ] = [] for estimation in response [ \"stopTimes\" ][ \"times\" ] . get ( \"Time\" , []): vehicle = Vehicle ( id = estimation [ \"codIssue\" ], route_id = estimation [ \"line\" ][ \"codLine\" ], route_way = Way ( estimation [ \"direction\" ]) if estimation [ \"direction\" ] in [ 0 , 1 ] else None , ) estimation = Estimation ( estimation = estimation [ \"time\" ], time = response [ \"stopTimes\" ][ \"actualDate\" ], ) result . append ( VehicleEstimation ( vehicle = vehicle , estimation = estimation ) ) return result get_routes_stop ( self , stop ) async Return all the routes that pass through the stop. Parameters: Name Type Description Default stop Stop Transport stop to get the routes for. required Returns: Type Description List[now8_api.domain.Route] Routes that pass through the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_routes_stop ( self , stop : Stop , ) -> List [ Route ]: raise NotImplementedError get_stops_city ( self , transport_types = None ) async Return all the stops of the selected transport types. Parameters: Name Type Description Default transport_types List[now8_api.domain.TransportType] Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. None Returns: Type Description List[now8_api.domain.Stop] All the stops of the selected transport types. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_stops_city ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: raise NotImplementedError get_stops_route ( self , route ) async Return all the stops of the selected route. Parameters: Name Type Description Default route Route Transport route to get the stops for. required Returns: Type Description Tuple[List[now8_api.domain.Stop], List[now8_api.domain.Stop]] Stops of the selected route for both ways in order. Exceptions: Type Description NotImplementedError If the method is not implemented for the route transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_stops_route ( self , route : Route , ) -> Tuple [ List [ Stop ], List [ Stop ]]: raise NotImplementedError _stop_id_api ( stop_id_user , transport_type ) private Return the Stop ID in the API format. Parameters: Name Type Description Default stop_id_user str Stop ID in the user format. required transport_type TransportType Stop transport type. required Returns: Type Description str Stop ID in the API format. Exceptions: Type Description TransportTypeError If the transport type is not supported. Source code in now8_api/service/city_data/madrid.py def _stop_id_api ( stop_id_user : str , transport_type : TransportType ) -> str : \"\"\"Return the Stop ID in the API format. Arguments: stop_id_user: Stop ID in the user format. transport_type: Stop transport type. Returns: Stop ID in the API format. Raises: TransportTypeError: If the transport type is not supported. \"\"\" if transport_type not in TRANSPORT_TYPE_STOP_PREFIXES : raise TransportTypeError ( transport_type = transport_type . name ) return TRANSPORT_TYPE_STOP_PREFIXES [ transport_type ] + stop_id_user _stop_id_user ( stop_id_api , transport_type ) private Return the Stop ID in the user format. Parameters: Name Type Description Default stop_id_api str Stop ID in the city API format. required transport_type TransportType Stop transport type. required Returns: Type Description str Stop ID in the user format. Exceptions: Type Description TransportTypeError If the transport type is not supported. Source code in now8_api/service/city_data/madrid.py def _stop_id_user ( stop_id_api : str , transport_type : TransportType ) -> str : \"\"\"Return the Stop ID in the user format. Arguments: stop_id_api: Stop ID in the city API format. transport_type: Stop transport type. Returns: Stop ID in the user format. Raises: TransportTypeError: If the transport type is not supported. \"\"\" if transport_type not in TRANSPORT_TYPE_STOP_PREFIXES : raise TransportTypeError ( transport_type = transport_type . name ) return stop_id_api . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ transport_type ] )","title":"  init  "},{"location":"reference/service/city_data/__init__/#now8_api.service.city_data.CityData","text":"City data abstract class. Abstracts the city data retrieval.","title":"CityData"},{"location":"reference/service/city_data/__init__/#now8_api.service.city_data.CityData.get_estimations","text":"Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[now8_api.domain.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. UpstreamError If the upstream city API fails. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: \"\"\"Return ETA for the next vehicles to the stop. Arguments: stop: Stop to get the next vehicle arrival estimations for. Returns: ETA for the next vehicles to the stop. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. UpstreamError: If the upstream city API fails. \"\"\"","title":"get_estimations()"},{"location":"reference/service/city_data/__init__/#now8_api.service.city_data.CityData.get_routes_stop","text":"Return all the routes that pass through the stop. Parameters: Name Type Description Default stop Stop Transport stop to get the routes for. required Returns: Type Description List[now8_api.domain.Route] Routes that pass through the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_routes_stop ( self , stop : Stop , ) -> List [ Route ]: \"\"\"Return all the routes that pass through the stop. Arguments: stop: Transport stop to get the routes for. Returns: Routes that pass through the stop. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. \"\"\"","title":"get_routes_stop()"},{"location":"reference/service/city_data/__init__/#now8_api.service.city_data.CityData.get_stops_city","text":"Return all the stops of the selected transport types. Parameters: Name Type Description Default transport_types List[now8_api.domain.TransportType] Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. None Returns: Type Description List[now8_api.domain.Stop] All the stops of the selected transport types. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_stops_city ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: \"\"\"Return all the stops of the selected transport types. Arguments: transport_types: Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. Returns: All the stops of the selected transport types. Raises: NotImplementedError: If the method is not implemented for the stop transport type in this city. \"\"\"","title":"get_stops_city()"},{"location":"reference/service/city_data/__init__/#now8_api.service.city_data.CityData.get_stops_route","text":"Return all the stops of the selected route. Parameters: Name Type Description Default route Route Transport route to get the stops for. required Returns: Type Description Tuple[List[now8_api.domain.Stop], List[now8_api.domain.Stop]] Stops of the selected route for both ways in order. Exceptions: Type Description NotImplementedError If the method is not implemented for the route transport type in this city. Source code in now8_api/service/city_data/__init__.py @abstractmethod async def get_stops_route ( self , route : Route , ) -> Tuple [ List [ Stop ], List [ Stop ]]: \"\"\"Return all the stops of the selected route. Arguments: route: Transport route to get the stops for. Returns: Stops of the selected route for both ways in order. Raises: NotImplementedError: If the method is not implemented for the route transport type in this city. \"\"\"","title":"get_stops_route()"},{"location":"reference/service/city_data/__init__/#now8_api.service.city_data.UpstreamError","text":"Custom exception for upstream API fauilures.","title":"UpstreamError"},{"location":"reference/service/city_data/__init__/#now8_api.service.city_data.UpstreamError.__init__","text":"Initialization method. Parameters: Name Type Description Default message Error message. required Source code in now8_api/service/city_data/__init__.py def __init__ ( self , message ): \"\"\"Initialization method. Arguments: message: Error message. \"\"\" super () . __init__ ( message )","title":"__init__()"},{"location":"reference/service/city_data/__init__/#now8_api.service.city_data.get_json","text":"Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: Type Description dict List of dictionaries with the parsed answer. Source code in now8_api/service/city_data/__init__.py @retry ( retry = ( retry_if_exception_type ( TimeoutError ) | retry_if_exception_type ( aiohttp . ClientResponseError ) ), stop = stop_after_attempt ( 3 ), wait = wait_exponential ( multiplier = 0.5 ), ) @validate_arguments async def get_json ( url : HttpUrl ) -> dict : \"\"\"Fetch the given URL and returns the result as a dictionary. Arguments: url: URL to fetch. Returns: List of dictionaries with the parsed answer. \"\"\" async with aiohttp . ClientSession () as session : async with session . get ( url , raise_for_status = True , timeout = 10 , ) as resp : return await resp . json ( content_type = None )","title":"get_json()"},{"location":"reference/service/city_data/__init__/#now8_api.service.city_data.madrid","text":"Module to store the city data of Madrid.","title":"madrid"},{"location":"reference/service/city_data/__init__/#now8_api.service.city_data.madrid.MadridCityData","text":"Madrid city data.","title":"MadridCityData"},{"location":"reference/service/city_data/__init__/#now8_api.service.city_data.madrid.MadridCityData.get_estimations","text":"Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[now8_api.domain.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. UpstreamError If the upstream city API fails. Source code in now8_api/service/city_data/madrid.py @overrides async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: try : response = await get_json ( f \"https://www.crtm.es/\" # type: ignore f \"widgets/api/GetStopsTimes.php\" f \"?codStop=\" f \" { stop . id . removeprefix ( 'par_' ) . removeprefix ( 'est_' ) } &\" f \"type=1&orderBy=2&stopTimesByIti=3\" ) except Exception as error : raise UpstreamError ( \"Upstream error. Check the stop id or try later.\" ) from error result : List [ VehicleEstimation ] = [] for estimation in response [ \"stopTimes\" ][ \"times\" ] . get ( \"Time\" , []): vehicle = Vehicle ( id = estimation [ \"codIssue\" ], route_id = estimation [ \"line\" ][ \"codLine\" ], route_way = Way ( estimation [ \"direction\" ]) if estimation [ \"direction\" ] in [ 0 , 1 ] else None , ) estimation = Estimation ( estimation = estimation [ \"time\" ], time = response [ \"stopTimes\" ][ \"actualDate\" ], ) result . append ( VehicleEstimation ( vehicle = vehicle , estimation = estimation ) ) return result","title":"get_estimations()"},{"location":"reference/service/city_data/__init__/#now8_api.service.city_data.madrid.MadridCityData.get_routes_stop","text":"Return all the routes that pass through the stop. Parameters: Name Type Description Default stop Stop Transport stop to get the routes for. required Returns: Type Description List[now8_api.domain.Route] Routes that pass through the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_routes_stop ( self , stop : Stop , ) -> List [ Route ]: raise NotImplementedError","title":"get_routes_stop()"},{"location":"reference/service/city_data/__init__/#now8_api.service.city_data.madrid.MadridCityData.get_stops_city","text":"Return all the stops of the selected transport types. Parameters: Name Type Description Default transport_types List[now8_api.domain.TransportType] Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. None Returns: Type Description List[now8_api.domain.Stop] All the stops of the selected transport types. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_stops_city ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: raise NotImplementedError","title":"get_stops_city()"},{"location":"reference/service/city_data/__init__/#now8_api.service.city_data.madrid.MadridCityData.get_stops_route","text":"Return all the stops of the selected route. Parameters: Name Type Description Default route Route Transport route to get the stops for. required Returns: Type Description Tuple[List[now8_api.domain.Stop], List[now8_api.domain.Stop]] Stops of the selected route for both ways in order. Exceptions: Type Description NotImplementedError If the method is not implemented for the route transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_stops_route ( self , route : Route , ) -> Tuple [ List [ Stop ], List [ Stop ]]: raise NotImplementedError","title":"get_stops_route()"},{"location":"reference/service/city_data/__init__/#now8_api.service.city_data.madrid._stop_id_api","text":"Return the Stop ID in the API format. Parameters: Name Type Description Default stop_id_user str Stop ID in the user format. required transport_type TransportType Stop transport type. required Returns: Type Description str Stop ID in the API format. Exceptions: Type Description TransportTypeError If the transport type is not supported. Source code in now8_api/service/city_data/madrid.py def _stop_id_api ( stop_id_user : str , transport_type : TransportType ) -> str : \"\"\"Return the Stop ID in the API format. Arguments: stop_id_user: Stop ID in the user format. transport_type: Stop transport type. Returns: Stop ID in the API format. Raises: TransportTypeError: If the transport type is not supported. \"\"\" if transport_type not in TRANSPORT_TYPE_STOP_PREFIXES : raise TransportTypeError ( transport_type = transport_type . name ) return TRANSPORT_TYPE_STOP_PREFIXES [ transport_type ] + stop_id_user","title":"_stop_id_api()"},{"location":"reference/service/city_data/__init__/#now8_api.service.city_data.madrid._stop_id_user","text":"Return the Stop ID in the user format. Parameters: Name Type Description Default stop_id_api str Stop ID in the city API format. required transport_type TransportType Stop transport type. required Returns: Type Description str Stop ID in the user format. Exceptions: Type Description TransportTypeError If the transport type is not supported. Source code in now8_api/service/city_data/madrid.py def _stop_id_user ( stop_id_api : str , transport_type : TransportType ) -> str : \"\"\"Return the Stop ID in the user format. Arguments: stop_id_api: Stop ID in the city API format. transport_type: Stop transport type. Returns: Stop ID in the user format. Raises: TransportTypeError: If the transport type is not supported. \"\"\" if transport_type not in TRANSPORT_TYPE_STOP_PREFIXES : raise TransportTypeError ( transport_type = transport_type . name ) return stop_id_api . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ transport_type ] )","title":"_stop_id_user()"},{"location":"reference/service/city_data/madrid/","text":"Module to store the city data of Madrid. MadridCityData pydantic-model Madrid city data. get_estimations ( self , stop ) async Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[now8_api.domain.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. UpstreamError If the upstream city API fails. Source code in now8_api/service/city_data/madrid.py @overrides async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: try : response = await get_json ( f \"https://www.crtm.es/\" # type: ignore f \"widgets/api/GetStopsTimes.php\" f \"?codStop=\" f \" { stop . id . removeprefix ( 'par_' ) . removeprefix ( 'est_' ) } &\" f \"type=1&orderBy=2&stopTimesByIti=3\" ) except Exception as error : raise UpstreamError ( \"Upstream error. Check the stop id or try later.\" ) from error result : List [ VehicleEstimation ] = [] for estimation in response [ \"stopTimes\" ][ \"times\" ] . get ( \"Time\" , []): vehicle = Vehicle ( id = estimation [ \"codIssue\" ], route_id = estimation [ \"line\" ][ \"codLine\" ], route_way = Way ( estimation [ \"direction\" ]) if estimation [ \"direction\" ] in [ 0 , 1 ] else None , ) estimation = Estimation ( estimation = estimation [ \"time\" ], time = response [ \"stopTimes\" ][ \"actualDate\" ], ) result . append ( VehicleEstimation ( vehicle = vehicle , estimation = estimation ) ) return result get_routes_stop ( self , stop ) async Return all the routes that pass through the stop. Parameters: Name Type Description Default stop Stop Transport stop to get the routes for. required Returns: Type Description List[now8_api.domain.Route] Routes that pass through the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_routes_stop ( self , stop : Stop , ) -> List [ Route ]: raise NotImplementedError get_stops_city ( self , transport_types = None ) async Return all the stops of the selected transport types. Parameters: Name Type Description Default transport_types List[now8_api.domain.TransportType] Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. None Returns: Type Description List[now8_api.domain.Stop] All the stops of the selected transport types. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_stops_city ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: raise NotImplementedError get_stops_route ( self , route ) async Return all the stops of the selected route. Parameters: Name Type Description Default route Route Transport route to get the stops for. required Returns: Type Description Tuple[List[now8_api.domain.Stop], List[now8_api.domain.Stop]] Stops of the selected route for both ways in order. Exceptions: Type Description NotImplementedError If the method is not implemented for the route transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_stops_route ( self , route : Route , ) -> Tuple [ List [ Stop ], List [ Stop ]]: raise NotImplementedError _stop_id_api ( stop_id_user , transport_type ) private Return the Stop ID in the API format. Parameters: Name Type Description Default stop_id_user str Stop ID in the user format. required transport_type TransportType Stop transport type. required Returns: Type Description str Stop ID in the API format. Exceptions: Type Description TransportTypeError If the transport type is not supported. Source code in now8_api/service/city_data/madrid.py def _stop_id_api ( stop_id_user : str , transport_type : TransportType ) -> str : \"\"\"Return the Stop ID in the API format. Arguments: stop_id_user: Stop ID in the user format. transport_type: Stop transport type. Returns: Stop ID in the API format. Raises: TransportTypeError: If the transport type is not supported. \"\"\" if transport_type not in TRANSPORT_TYPE_STOP_PREFIXES : raise TransportTypeError ( transport_type = transport_type . name ) return TRANSPORT_TYPE_STOP_PREFIXES [ transport_type ] + stop_id_user _stop_id_user ( stop_id_api , transport_type ) private Return the Stop ID in the user format. Parameters: Name Type Description Default stop_id_api str Stop ID in the city API format. required transport_type TransportType Stop transport type. required Returns: Type Description str Stop ID in the user format. Exceptions: Type Description TransportTypeError If the transport type is not supported. Source code in now8_api/service/city_data/madrid.py def _stop_id_user ( stop_id_api : str , transport_type : TransportType ) -> str : \"\"\"Return the Stop ID in the user format. Arguments: stop_id_api: Stop ID in the city API format. transport_type: Stop transport type. Returns: Stop ID in the user format. Raises: TransportTypeError: If the transport type is not supported. \"\"\" if transport_type not in TRANSPORT_TYPE_STOP_PREFIXES : raise TransportTypeError ( transport_type = transport_type . name ) return stop_id_api . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ transport_type ] )","title":"Madrid"},{"location":"reference/service/city_data/madrid/#now8_api.service.city_data.madrid.MadridCityData","text":"Madrid city data.","title":"MadridCityData"},{"location":"reference/service/city_data/madrid/#now8_api.service.city_data.madrid.MadridCityData.get_estimations","text":"Return ETA for the next vehicles to the stop. Parameters: Name Type Description Default stop Stop Stop to get the next vehicle arrival estimations for. required Returns: Type Description List[now8_api.domain.VehicleEstimation] ETA for the next vehicles to the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. UpstreamError If the upstream city API fails. Source code in now8_api/service/city_data/madrid.py @overrides async def get_estimations ( self , stop : Stop , ) -> List [ VehicleEstimation ]: try : response = await get_json ( f \"https://www.crtm.es/\" # type: ignore f \"widgets/api/GetStopsTimes.php\" f \"?codStop=\" f \" { stop . id . removeprefix ( 'par_' ) . removeprefix ( 'est_' ) } &\" f \"type=1&orderBy=2&stopTimesByIti=3\" ) except Exception as error : raise UpstreamError ( \"Upstream error. Check the stop id or try later.\" ) from error result : List [ VehicleEstimation ] = [] for estimation in response [ \"stopTimes\" ][ \"times\" ] . get ( \"Time\" , []): vehicle = Vehicle ( id = estimation [ \"codIssue\" ], route_id = estimation [ \"line\" ][ \"codLine\" ], route_way = Way ( estimation [ \"direction\" ]) if estimation [ \"direction\" ] in [ 0 , 1 ] else None , ) estimation = Estimation ( estimation = estimation [ \"time\" ], time = response [ \"stopTimes\" ][ \"actualDate\" ], ) result . append ( VehicleEstimation ( vehicle = vehicle , estimation = estimation ) ) return result","title":"get_estimations()"},{"location":"reference/service/city_data/madrid/#now8_api.service.city_data.madrid.MadridCityData.get_routes_stop","text":"Return all the routes that pass through the stop. Parameters: Name Type Description Default stop Stop Transport stop to get the routes for. required Returns: Type Description List[now8_api.domain.Route] Routes that pass through the stop. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_routes_stop ( self , stop : Stop , ) -> List [ Route ]: raise NotImplementedError","title":"get_routes_stop()"},{"location":"reference/service/city_data/madrid/#now8_api.service.city_data.madrid.MadridCityData.get_stops_city","text":"Return all the stops of the selected transport types. Parameters: Name Type Description Default transport_types List[now8_api.domain.TransportType] Transport types to get the stops for. If none are passed, all of the available ones for the city will be included. None Returns: Type Description List[now8_api.domain.Stop] All the stops of the selected transport types. Exceptions: Type Description NotImplementedError If the method is not implemented for the stop transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_stops_city ( self , transport_types : List [ TransportType ] = None , ) -> List [ Stop ]: raise NotImplementedError","title":"get_stops_city()"},{"location":"reference/service/city_data/madrid/#now8_api.service.city_data.madrid.MadridCityData.get_stops_route","text":"Return all the stops of the selected route. Parameters: Name Type Description Default route Route Transport route to get the stops for. required Returns: Type Description Tuple[List[now8_api.domain.Stop], List[now8_api.domain.Stop]] Stops of the selected route for both ways in order. Exceptions: Type Description NotImplementedError If the method is not implemented for the route transport type in this city. Source code in now8_api/service/city_data/madrid.py @overrides async def get_stops_route ( self , route : Route , ) -> Tuple [ List [ Stop ], List [ Stop ]]: raise NotImplementedError","title":"get_stops_route()"},{"location":"reference/service/city_data/madrid/#now8_api.service.city_data.madrid._stop_id_api","text":"Return the Stop ID in the API format. Parameters: Name Type Description Default stop_id_user str Stop ID in the user format. required transport_type TransportType Stop transport type. required Returns: Type Description str Stop ID in the API format. Exceptions: Type Description TransportTypeError If the transport type is not supported. Source code in now8_api/service/city_data/madrid.py def _stop_id_api ( stop_id_user : str , transport_type : TransportType ) -> str : \"\"\"Return the Stop ID in the API format. Arguments: stop_id_user: Stop ID in the user format. transport_type: Stop transport type. Returns: Stop ID in the API format. Raises: TransportTypeError: If the transport type is not supported. \"\"\" if transport_type not in TRANSPORT_TYPE_STOP_PREFIXES : raise TransportTypeError ( transport_type = transport_type . name ) return TRANSPORT_TYPE_STOP_PREFIXES [ transport_type ] + stop_id_user","title":"_stop_id_api()"},{"location":"reference/service/city_data/madrid/#now8_api.service.city_data.madrid._stop_id_user","text":"Return the Stop ID in the user format. Parameters: Name Type Description Default stop_id_api str Stop ID in the city API format. required transport_type TransportType Stop transport type. required Returns: Type Description str Stop ID in the user format. Exceptions: Type Description TransportTypeError If the transport type is not supported. Source code in now8_api/service/city_data/madrid.py def _stop_id_user ( stop_id_api : str , transport_type : TransportType ) -> str : \"\"\"Return the Stop ID in the user format. Arguments: stop_id_api: Stop ID in the city API format. transport_type: Stop transport type. Returns: Stop ID in the user format. Raises: TransportTypeError: If the transport type is not supported. \"\"\" if transport_type not in TRANSPORT_TYPE_STOP_PREFIXES : raise TransportTypeError ( transport_type = transport_type . name ) return stop_id_api . removeprefix ( TRANSPORT_TYPE_STOP_PREFIXES [ transport_type ] )","title":"_stop_id_user()"},{"location":"topics/code_structure/","text":"Code structure The main package is contained in the now8_api/ directory. The structure is as follows: +------------+ +-----------+ | db backend | | City APIs | +------------+ +-----------+ | | +-------|----------------|---+ | | | | | +------+ +--------+ | | | | data | | domain | | | | +------+ +--------+ | | | | | | | | | | +-------------------+ | | | | service | | | | +-------------------+ | | | | | | +-------------+ | | | entrypoints | | | +-------------+ | | | | +-------|--------------------+ | +----------+ | frontend | +----------+ Each component should only connect with its connected ones. Each component contains a __init__.py file that stores the functions shared in the component, for example a hello_world() function shared among different entrypoints (API, CLI, \u2026). Apart from this components, there is the __init__.py file of the now8_api package. Components Data This component is responsible for abstracting the data persistence. Database Abstraction of the local database. Domain domain contains the business actors and logic. It has no dependencies, so that it can be tested alone and the code is as simple and clear as possible. Service This component obtains data from the data or from the City APIs and interacts with doamin to validate it and process it when called by the entrypoints component. Having this layer decouples the domain from the data and the entrypoints , which facilitates testing and implementing new functionality. City Data Abstraction of city transport APIs and other city data sources. Entrypoints This component provides access to the now8_api package functionality. The main entrypoint is a HTTP REST API but other entrypoints, such as CLIs, should be placed here.","title":"Code structure"},{"location":"topics/code_structure/#code-structure","text":"The main package is contained in the now8_api/ directory. The structure is as follows: +------------+ +-----------+ | db backend | | City APIs | +------------+ +-----------+ | | +-------|----------------|---+ | | | | | +------+ +--------+ | | | | data | | domain | | | | +------+ +--------+ | | | | | | | | | | +-------------------+ | | | | service | | | | +-------------------+ | | | | | | +-------------+ | | | entrypoints | | | +-------------+ | | | | +-------|--------------------+ | +----------+ | frontend | +----------+ Each component should only connect with its connected ones. Each component contains a __init__.py file that stores the functions shared in the component, for example a hello_world() function shared among different entrypoints (API, CLI, \u2026). Apart from this components, there is the __init__.py file of the now8_api package.","title":"Code structure"},{"location":"topics/code_structure/#components","text":"","title":"Components"},{"location":"topics/code_structure/#data","text":"This component is responsible for abstracting the data persistence.","title":"Data"},{"location":"topics/code_structure/#database","text":"Abstraction of the local database.","title":"Database"},{"location":"topics/code_structure/#domain","text":"domain contains the business actors and logic. It has no dependencies, so that it can be tested alone and the code is as simple and clear as possible.","title":"Domain"},{"location":"topics/code_structure/#service","text":"This component obtains data from the data or from the City APIs and interacts with doamin to validate it and process it when called by the entrypoints component. Having this layer decouples the domain from the data and the entrypoints , which facilitates testing and implementing new functionality.","title":"Service"},{"location":"topics/code_structure/#city-data","text":"Abstraction of city transport APIs and other city data sources.","title":"City Data"},{"location":"topics/code_structure/#entrypoints","text":"This component provides access to the now8_api package functionality. The main entrypoint is a HTTP REST API but other entrypoints, such as CLIs, should be placed here.","title":"Entrypoints"},{"location":"tutorials/docker/","text":"Docker The HTTP API server of this project can be run using docker . Building To build the Docker image of the HTTP API server of this project run (from the root directory of this repository): docker build -t local/now8-api . Running Then, to run the server execute (filling the variable values): docker run -d --name now8-api -p 80 :80 -e WEB_CONCURRENCY = 4 local/now8-api You can then access the HTTP API at http://localhost:80 . If WEB_CONCURRENCY is not set, the number of workers will be two times the number of CPU cores/threads. The environment variables from tiangolo/uvicorn-gunicorn-fastapi are supported.","title":"Docker"},{"location":"tutorials/docker/#docker","text":"The HTTP API server of this project can be run using docker .","title":"Docker"},{"location":"tutorials/docker/#building","text":"To build the Docker image of the HTTP API server of this project run (from the root directory of this repository): docker build -t local/now8-api .","title":"Building"},{"location":"tutorials/docker/#running","text":"Then, to run the server execute (filling the variable values): docker run -d --name now8-api -p 80 :80 -e WEB_CONCURRENCY = 4 local/now8-api You can then access the HTTP API at http://localhost:80 . If WEB_CONCURRENCY is not set, the number of workers will be two times the number of CPU cores/threads. The environment variables from tiangolo/uvicorn-gunicorn-fastapi are supported.","title":"Running"},{"location":"tutorials/getting_started/","text":"Getting started Installation Run pip install . . Development To install also the development dependencies, run make install Configuration Choose the city to serve for with the following environment variable: CITY = madrid Then, also define the following environment variables with the database (PostgreSQL) connection settings: DB_NAME = DB_HOST = DB_USER = DB_PASS = DB_PORT = Ways of defining them: manually using export sourcing a script with the export commands saving them in your virtualenv postactivate script ... Running Before running now8_api , start a PostgreSQL database with the PostGIS extension installed. You can run: docker run -d --name postgres \\ -e POSTGRES_USER = postgres \\ -e POSTGRES_PASSWORD = postgres \\ -e POSTGRES_DB = postgres \\ -p 5432 :5432 \\ postgis/postgis You don't need to bind the host port if both now8_api and the database are running in Docker in the same network (add --network now8 to both). Nevertheless, it might be useful to bind the host port if using the database for development so that you can run the code and tests directly from the sources. In this case, the database configuration environment variables for now8_api should be: DB_NAME = postgres DB_HOST = postgres DB_USER = postgres DB_PASS = postgres DB_PORT = 5432 Which are the default values. If you are using a Python virtual environment, you can add them to $VIRTUAL_ENV/bin/postactivate adding export before each one of them. Development For development, you can run the project with: make run You can then access the API at http://localhost:8000 and the Swagger UI (interactive API documentation) at http://localhost:8000/docs . Production For production, a process manager is recommended to handle multiple workers, such as gunicorn . For example: gunicorn -b 0 .0.0.0:8000 -w 4 -k uvicorn.workers.UvicornWorker now8_api.entrypoints.api.main:api Options: -b option specifies the binding host and port. -w option specifies the number of workers. -k option specifies the type of workers, that need to be uvicorn.workers.UvicornWorker as specified at the Uvicorn Documentation . Populating the database The database should contain the GTFS information for the city, it can be populated using OpenTransitTools/gtfsdb . For example, for adding the intercity buses information for Madrid, run: docker run \\ --network now8 \\ local/gtfsdb \\ --database_url postgresql://postgres:postgres@postgres:5432/postgres \\ --is_geospatial \\ https://www.arcgis.com/sharing/rest/content/items/885399f83408473c8d815e40c5e702b7/data Don't forget to run the PostgreSQL (with the PostGIS extension) Docker in the same network (i.e., now8 ).","title":"Getting started"},{"location":"tutorials/getting_started/#getting-started","text":"","title":"Getting started"},{"location":"tutorials/getting_started/#installation","text":"Run pip install . .","title":"Installation"},{"location":"tutorials/getting_started/#development","text":"To install also the development dependencies, run make install","title":"Development"},{"location":"tutorials/getting_started/#configuration","text":"Choose the city to serve for with the following environment variable: CITY = madrid Then, also define the following environment variables with the database (PostgreSQL) connection settings: DB_NAME = DB_HOST = DB_USER = DB_PASS = DB_PORT = Ways of defining them: manually using export sourcing a script with the export commands saving them in your virtualenv postactivate script ...","title":"Configuration"},{"location":"tutorials/getting_started/#running","text":"Before running now8_api , start a PostgreSQL database with the PostGIS extension installed. You can run: docker run -d --name postgres \\ -e POSTGRES_USER = postgres \\ -e POSTGRES_PASSWORD = postgres \\ -e POSTGRES_DB = postgres \\ -p 5432 :5432 \\ postgis/postgis You don't need to bind the host port if both now8_api and the database are running in Docker in the same network (add --network now8 to both). Nevertheless, it might be useful to bind the host port if using the database for development so that you can run the code and tests directly from the sources. In this case, the database configuration environment variables for now8_api should be: DB_NAME = postgres DB_HOST = postgres DB_USER = postgres DB_PASS = postgres DB_PORT = 5432 Which are the default values. If you are using a Python virtual environment, you can add them to $VIRTUAL_ENV/bin/postactivate adding export before each one of them.","title":"Running"},{"location":"tutorials/getting_started/#development_1","text":"For development, you can run the project with: make run You can then access the API at http://localhost:8000 and the Swagger UI (interactive API documentation) at http://localhost:8000/docs .","title":"Development"},{"location":"tutorials/getting_started/#production","text":"For production, a process manager is recommended to handle multiple workers, such as gunicorn . For example: gunicorn -b 0 .0.0.0:8000 -w 4 -k uvicorn.workers.UvicornWorker now8_api.entrypoints.api.main:api Options: -b option specifies the binding host and port. -w option specifies the number of workers. -k option specifies the type of workers, that need to be uvicorn.workers.UvicornWorker as specified at the Uvicorn Documentation .","title":"Production"},{"location":"tutorials/getting_started/#populating-the-database","text":"The database should contain the GTFS information for the city, it can be populated using OpenTransitTools/gtfsdb . For example, for adding the intercity buses information for Madrid, run: docker run \\ --network now8 \\ local/gtfsdb \\ --database_url postgresql://postgres:postgres@postgres:5432/postgres \\ --is_geospatial \\ https://www.arcgis.com/sharing/rest/content/items/885399f83408473c8d815e40c5e702b7/data Don't forget to run the PostgreSQL (with the PostGIS extension) Docker in the same network (i.e., now8 ).","title":"Populating the database"}]}